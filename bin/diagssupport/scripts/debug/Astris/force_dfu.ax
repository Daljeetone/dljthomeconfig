#!/usr/bin/tclsh

## Astris
# > script force_dfu.ax
# or
# > source force_dfu.ax
# > force_dfu
#

## Shell
# $ astris --script force_dfu.ax
#

::namespace eval ::force_dfu {

    variable SOCS
    set SOCS [dict create]

    set M7_SOC {
        memap 4
        io_base 0x40000000
        gpio_base_addr 0x6810000
        force_dfu_gpio_offset 0x58
        gpio_cfg 0x283
        pmgr_addr 0x6c00000
        pmgr_gpio_ps 0x200a0
        pmgr_gpio_cfg 0xF
    }

    set Elba_SOC {
        memap 4
        cpu0_addr 0xC2010000
        io_base 0x200000000
        gpio_base_addr 0xF100000
        force_dfu_gpio_offset 0x2E8
        gpio_cfg 0x283
        pmgr_addr 0x20e000000
        pmgr_gpio_ps 0x80118
        pmgr_gpio_cfg 0xF
        dram_resets {
            dcs0.AMPSCA.ampscagen.DRAM_Resetn 0x20042000c
            dcs1.AMPSCA.ampscagen.DRAM_Resetn 0x20046000c
            dcs2.AMPSCA.ampscagen.DRAM_Resetn 0x2004a000c
            dcs3.AMPSCA.ampscagen.DRAM_Resetn 0x2004e000c
            dcs4.AMPSCA.ampscagen.DRAM_Resetn 0x20052000c
            dcs5.AMPSCA.ampscagen.DRAM_Resetn 0x20056000c
            dcs6.AMPSCA.ampscagen.DRAM_Resetn 0x2005a000c
            dcs7.AMPSCA.ampscagen.DRAM_Resetn 0x2005e000c
        }
    }

    set Malta_SOC {
        memap 4
        cpu0_addr 0xC2010000
        io_base 0x200000000
        gpio_base_addr 0xF100000
        force_dfu_gpio_offset 0x1EC
        gpio_cfg 0x283
        pmgr_addr 0x20e000000
        pmgr_gpio_ps 0x80118
        pmgr_gpio_cfg 0xF
        dram_resets {
            dcs0.AMPSCA.ampscagen.DRAM_Resetn 0x20022000c
            dcs1.AMPSCA.ampscagen.DRAM_Resetn 0x20026000c
            dcs2.AMPSCA.ampscagen.DRAM_Resetn 0x2002a000c
            dcs3.AMPSCA.ampscagen.DRAM_Resetn 0x2002e000c
        }
    }

    set Maui_SOC {
        memap 4
        cpu0_addr 0xC2010000
        io_base 0x200000000
        gpio_base_addr 0xF100000
        force_dfu_gpio_offset 0x1EC
        gpio_cfg 0x283
        pmgr_addr 0x20e000000
        pmgr_gpio_ps 0x80118
        pmgr_gpio_cfg 0xF
        dram_resets {
            dcs0.AMPSCA.ampscagen.DRAM_Resetn 0x20022000c
            dcs1.AMPSCA.ampscagen.DRAM_Resetn 0x20026000c
            dcs2.AMPSCA.ampscagen.DRAM_Resetn 0x2002a000c
            dcs3.AMPSCA.ampscagen.DRAM_Resetn 0x2002e000c
        }
    }

    set Capri_SOC {
        memap 4
        cpu0_addr 0xC2010000
        io_base 0x200000000
        gpio_base_addr 0x00E300000
        force_dfu_gpio_offset 0x1A8
        gpio_cfg 0x283
        pmgr_addr 0x20e000000
        pmgr_gpio_ps 0x20128
        pmgr_gpio_cfg 0xF
    }

    set Fiji_SOC {
        memap 4
        cpu0_addr 0xC2010000
        io_base 0x200000000
        gpio_base_addr 0x00E300000
        force_dfu_gpio_offset 0x1B0
        gpio_cfg  0x283
        pmgr_addr 0x20e000000
        pmgr_gpio_ps 0x20128
        pmgr_gpio_cfg 0xF
    }

    set Alcatraz_SOC {
        memap 4
        cpu0_addr 0xC2010000
        io_base 0x200000000
        gpio_base_addr 0x00E300000
        force_dfu_gpio_offset 0x1A8
        gpio_cfg  0x283
        pmgr_addr 0x20e000000
        pmgr_gpio_ps 0x20040
        pmgr_gpio_cfg 0xF
    }

    set Bali_SOC {
        memap 0
        io_base 0x00000000
        gpio_base_addr 0x3FA00000
        force_dfu_gpio_offset 0x318
        gpio_cfg  0x283
        pmgr_addr 0x3F100000
        pmgr_gpio_ps 0x112C
        pmgr_gpio_cfg 0x02FF
    }

    set H5P_SOC {
        memap 0
        io_base 0x00000000
        gpio_base_addr 0x3FA00000
        force_dfu_gpio_offset 0x338
        gpio_cfg  0x283
        pmgr_addr 0x3F100000
        pmgr_gpio_ps 0x112C
        pmgr_gpio_cfg 0x02FF
    }

    set H4I_SOC {
        memap 0
        io_base 0x00000000
        gpio_base_addr 0x3FA00000
        force_dfu_gpio_offset 0x210
        gpio_cfg  0x283
        pmgr_addr 0x3F100000
        pmgr_gpio_ps 0x112C
        pmgr_gpio_cfg 0x02FF
    }

    set H4G_SOC {
        memap 0
        io_base 0x00000000
        gpio_base_addr 0x3FA00000
        force_dfu_gpio_offset 0xF8
        gpio_cfg  0x283
        pmgr_addr 0x3F100000
        pmgr_gpio_ps 0x112C
        pmgr_gpio_cfg 0x02FF
    }

    set H4A_SOC {
        memap 0
        io_base 0x00000000
        gpio_base_addr 0x3FA00000
        force_dfu_gpio_offset 0x68
        gpio_cfg  0x283
        pmgr_addr 0x3F100000
        pmgr_gpio_ps 0x112C
        pmgr_gpio_cfg 0x02FF
    }

    set H4P_SOC {
        memap 0
        io_base 0x00000000
        gpio_base_addr 0x3FA00000
        force_dfu_gpio_offset 0x68
        gpio_cfg  0x283
        pmgr_addr 0x3F100000
        pmgr_gpio_ps 0x112C
        pmgr_gpio_cfg 0x02FF
    }

    dict set SOCS M7 ${M7_SOC}
    dict set SOCS Elba ${Elba_SOC}
    dict set SOCS Malta ${Malta_SOC}
    dict set SOCS Maui ${Maui_SOC}
    dict set SOCS Capri ${Capri_SOC}
    dict set SOCS Fiji ${Fiji_SOC}
    dict set SOCS Alcatraz ${Alcatraz_SOC}
    dict set SOCS Bali ${Bali_SOC}
    dict set SOCS H5P ${H5P_SOC}
    dict set SOCS H4I ${H4I_SOC}
    dict set SOCS H4G ${H4G_SOC}
    dict set SOCS H4A ${H4A_SOC}
    dict set SOCS H4P ${H4P_SOC}

    ::namespace path [list ::astris ::astris::console ::astris::console::native]

    proc clear_reset_catch {soc_name} {
        variable SOCS
        variable cpu0_addr

        set SOCS $::force_dfu::SOCS
        if { [lsearch {Alcatraz Fiji Capri Maui Malta Elba} ${soc_name}] >= 0 } {
            set cpu0_addr [dict get ${SOCS} ${soc_name} cpu0_addr]
            memapw -ap 1 [expr { ${cpu0_addr} + 0x24 }] 0
        }

    }

    proc try_force_dfu {soc_name cpu} {
        # configure the GPIO again
        configure_force_dfu_gio ${soc_name}

        # set the watchpoint again in case someone does another store to the FORCE_DFU GPIO address
        set_force_dfu_watchpoint ${soc_name}

        # all set
        go

        # see if we hit the watchpoint again, if so we will handle it
        wait_cpustate ${soc_name} ${cpu} HardwareWatch
    }

    proc wait_cpustate {soc_name cpu state} {
        ::astris::console::native::support::cpu_state_changed
        set i 0
        while { [::astris::primitive::cpustate ${cpu}] != ${state} } {
            if { [incr i] == 50 } {
                break
            }
            after 50
        }

        halt -q
        wp clear
        step -q

        if { ${i} < 50 } {
            try_force_dfu ${soc_name} ${cpu}
        } else {
            # clear the watchpoint
            puts "with any luck we're now in SecureROM DFU mode"
            if { [info exists ::env(RACK_DIR)] } {
                exec printf "\r\n\r\n## RACK FORCE DFU ##\r\n\r\n" > $::env(RACK_DIR)/uart_fifo
            }
            go
        }
        ::astris::console::native::support::cpu_state_changed
    }

    proc force_dfu_gpio_address {soc_name} {
        variable SOCS
        variable memap
        variable io_base
        variable gpio_base_addr
        variable force_dfu_gpio_offset
        variable gpio_cfg

        set SOCS $::force_dfu::SOCS
        set io_base [dict get ${SOCS} ${soc_name} io_base]
        set gpio_base_addr [dict get ${SOCS} ${soc_name} gpio_base_addr]
        set force_dfu_gpio_offset [dict get ${SOCS} ${soc_name} force_dfu_gpio_offset]

        expr { ${io_base} + ${gpio_base_addr} + ${force_dfu_gpio_offset} }
    }

    proc set_force_dfu_watchpoint {soc_name} {
        wp set -s [force_dfu_gpio_address ${soc_name}]
    }

    proc configure_force_dfu_gio {soc_name} {
        variable SOCS
        variable memap
        variable gpio_cfg

        set SOCS $::force_dfu::SOCS
        set memap [dict get ${SOCS} ${soc_name} memap]
        set gpio_cfg [dict get ${SOCS} ${soc_name} gpio_cfg]

        mem -memap ${memap} [force_dfu_gpio_address ${soc_name}] ${gpio_cfg}
    }

    proc enable_gpio_block {soc_name} {
        variable SOCS
        variable memap
        variable pmgr_addr
        variable pmgr_gpio_ps
        variable pmgr_gpio_cfg
        variable io_base

        set SOCS $::force_dfu::SOCS

        set memap [dict get ${SOCS} ${soc_name} memap]
        set pmgr_addr [dict get ${SOCS} ${soc_name} pmgr_addr]
        set pmgr_gpio_ps [dict get ${SOCS} ${soc_name} pmgr_gpio_ps]
        set pmgr_gpio_cfg [dict get ${SOCS} ${soc_name} pmgr_gpio_cfg]

        set pmgr_gpio_ps_addr [expr { ${pmgr_addr} + ${pmgr_gpio_ps} }]
        mem -memap ${memap} ${pmgr_gpio_ps_addr} ${pmgr_gpio_cfg}
    }

    proc dram_reset {soc_name} {
        variable SOCS
        variable memap
        set SOCS $::force_dfu::SOCS
        set memap [dict get ${SOCS} ${soc_name} memap]
        if { [dict exists ${SOCS} ${soc_name} dram_resets] } {
            set dram_resets [dict get ${SOCS} ${soc_name} dram_resets]
            foreach {reg addr} ${dram_resets} {
                puts "${reg} = 0"
                mem -memap ${memap} ${addr} 0
            }
            foreach {reg addr} ${dram_resets} {
                puts "${reg} = 1"
                mem -memap ${memap} ${addr} 1
            }
        }
    }

    proc force_dfu {} {
        variable SOCS
        variable soc_name
        variable dbgwrap 0xCF001000

        ::astris::console::native::reset

        explore
        ::namespace path [list ::astris ::astris::console ::astris::console::native ::astris::soc]

        set soc_name [soc]

        set SOCS $::force_dfu::SOCS
        if { ! [dict exists ${SOCS} ${soc_name}] } {
            error "force_dfu: unknown soc: ${soc_name}"
        }

        # soft reset and hold
        ::astris::soc::fromreset

        # reset dram
        dram_reset ${soc_name}

        # no cpu is selected at this point, select the first one
        cpu 0

        # clear out any unexpected bkpts or watchpoints
        bp clear
        wp clear

        # enable the GPIO block
        enable_gpio_block ${soc_name}

        # configure the FORCE_DFU GPIO
        configure_force_dfu_gio ${soc_name}

        # set a watchpoint on the FORCE_DFU GPIO address
        set_force_dfu_watchpoint ${soc_name}

        # all set, now go
        go

        # action for the watchpoint
        wait_cpustate ${soc_name} CPU0 HardwareWatch

        # clear the catch reset vector
        clear_reset_catch ${soc_name}

        return 0
    }

    ::namespace eval ::console {
        define_command force_dfu {args} {
            ".Sh NAME"
            ".Nm force_dfu"
            ".Nd force the SoC into SecureROM DFU mode"
            ".Sh SYNOPSIS"
            ".Nm"
            ".Sh DESCRIPTION"
            "The" ".Nm" "command forces the SoC into SecureROM DFU mode via a CPU watchpoint on the FORCE_DFU GPIO pin."
        } {
            ::force_dfu::force_dfu
        }
    }
}

if { [namespace exists ::script] && ! [namespace exists ::initax] } {
    ::force_dfu::force_dfu
}
