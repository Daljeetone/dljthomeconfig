Branching with git for Diags:

- When you first start with a git project, you'll have a master branch.  We will end up doing very little with this branch.
- All main development will happen on a 'devel' branch.  This will be our "top of tree" branch when using git.
- From the 'devel' branch, we will branch off for Build trains (towards release), factory/release branches etc.
- We will periodically merge clean builds from devel to 'master'.  This can happen as part of nightly/request builds.

Here's a list of branches, and what they'd contain and signify:
- master: top of tree, stable code.  Snapshots of the mainline 'devel' branch at points coinciding with successful release/request builds. origin/master is the main branch where the source code of HEAD always reflects a production-ready state. Always production-ready. Keep that in mind.
- devel: top of tree, development code.  This is where all the engineers merge their daily code.  This may be allowed to break (we should never let 'master' break), obviously though we'd want to unbreak things as soon as possible.  Automatic, nightly builds happen from this branch.  Request builds would also happen from this branch.  For example, when we're ready to make a diags release for N51, we would do the following steps:
	(1) Build the devel branch's latest bits, make sure this build succeeds,
	(2) Merge 'devel' to 'master', and create a new tag with the version number based on 'master' after the merge: example: 'efi-n51-13C0586',
	(3) Build a release build from the tag'd revisions, package it, and release on the webpage.
	
	By definition, each merge to 'master' from 'devel' should result in a release version number, and this should be automatic.  'master' should basically be snapshots of things we have (or could have) released.
	
- innsbruck: For example, towards the closing of Innsbruck, we would branch 'devel' or 'master' to 'innsbruck', and all future Innsbruck related, necessary checkins would go into 'innsbruck' and get merged back to 'devel'.
- factory_n51_dvt: If we were early in Innsbruck's life-cycle, 'devel' would exist, and 'innsbruck' would not.  Given this, we would branch from 'devel' or 'master' to an 'factory_n51_dvt' branch.  All N51 DVT factory related fixes would go into 'factory_n51_dvt' branch, and be merged back to 'devel'.

Users in the factory would be committing their hotfix changes to the 'factory_n51' branch.  We would support creating tags from these factory branches as well, similar to how we do it on 'master':
	(1) Build the code, make sure the build works, if so,
	(2) create a new tag: 'factory-efi-n51-13C0586a',
	(3) build a release build from the tag'd revision, package it, and release on the webpage/email.

This covers the mainline development workflow, factory branching, branching towards CoreOS Build-train GMc releases.  It also covers an always-stable 'master' branch, that gets periodically/automatically snapshotted from 'devel'.  What we have not covered so far are bug-fix branches, feature branches, and day-to-day multitasking branches.

Let's cover that now:

Bug-fix branches:  You've got a radar that you need to work on.  Worst-case scenario is that this radar involves changes across ALL kinds of subsystems and APIs.  This is a big, scary change!  No problem, make a branch, name it after the radar number (note: radar would be required). If the radar number was 12345678, we'd name the branch: 'pr-12345678'.  PR meaning 'per radar', or 'patch for radar'.  A user could make as many intermediary commits to this branch as necessary.  User does not necessarily need to push this branch to the upstream 'origin' server, but can (ex: for code review when the branch is done).  Once the branch is done, we would code review it, buddy it as normal, and merge it to 'devel'.  This can be done asynchronously from the upstream repository, by allowing user a (the code-change author) to push to user b (the peer reviewer) directly.  That could get complicated though, so I suggest pushing these branches to the server.

Rules for bug-fix branches: Must be branched from 'devel', and must merge back to 'devel'.  No other source or destination is valid.

Feature branches: Similar to above, can even follow the same model (after all, all new features have a radar, right?).  This is basically the same as above.

Rules for feature branches: same as bug-fix branches. Source must be 'devel', merge-back must go to 'devel'.

Multi-tasking branches:  In perforce, we had workspaces.  Workspaces necessitated checking out the same code multiple times, chewing through disk space on your machine. Yuck!  As an engineer, you pull down 'devel' to your machine (mainly).  You can then create as many branches as you want (and can think of them as workspaces).  The trick is this: do not push your commits upstream.  Once you've finished your work, commit it locally.  And merge it back to 'devel' if necessary.  Then you push from 'devel'.

Merging:
When merging PR (bug-fix) or feature-work branches back to 'devel', please always use this command:
git merge --no-ff.  This will create 1 commit object that represents all the changes made on your branch (and will make backing out changes must easier for DRIs/integrators).


Options:
remove 'devel' branch, and use 'master' as the development/main branch.

Resources:
<http://nvie.com/posts/a-successful-git-branching-model/>

