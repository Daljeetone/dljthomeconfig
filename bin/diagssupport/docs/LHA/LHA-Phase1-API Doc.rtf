{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf340
{\fonttbl\f0\fnil\fcharset0 MyriadSet-Text;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww17980\viewh19220\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\qc

\f0\b\fs36 \cf0 Lua Hardware Access-Phase 1
\b0\fs24 \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 This document contains the latest versioned and documented APIs for the Lua Hardware Access libraries built into the EFI Shell and the Lua Hardware Access OS X package (interpreter + kext). The EFI and OS X implementations differ from the standard lua distribution by removing the math library, using signed 64-bit integers for lua_Number and providing the following custom APIs for hardware access.\
\
For documentation on Lua, see http://www.lua.org.\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b\fs26 \cf0 SMBUS Access
\b0\fs24 \
\
hw.smbus.read_block (bus, device_address, register_address ,register_address_size,length)\
          bus: positive integer\
	device_address: positive integer\
	register_address_size: positive integer\
          register_address: positive integer\
          length: positive integer\
	Read "length" number of bytes of data from a device at "device_address" on bus "bus" starting from a register at "register_address" whose address size is specified by "register_address_size".\
\
hw.smbus.write_block (bus, device_address, register_address ,register_address_size,data)\
         bus: positive integer\
	device_address: positive integer\
	register_address_size: positive integer\
          register_address: positive integer\
	data: string\
	Write a block of data specified by "data" into a device at "device_address" on bus "bus" ,starting at a register at "register_address" whose address size is specified by "register_address_size".\
\
hw.smbus.quick_read (bus,device_address)\
         bus: positive integer\
	device_address: positive integer\
	Execute a zero-byte read of the device at "device_address" on bus "bus" by simply pumping out the address on the bus and waiting for ACK.\
\
hw.smbus.send_bytes (bus,device_address, data)\
         bus: positive integer\
	device_address: positive integer\
	data: string\
	Send  the data specified by "data" to the device at "device_address" on bus "bus".\
\
hw.smbus.receive_bytes (bus,device_address, length)\
          bus: positive integer\
	device_address: positive integer\
          length: positive integer\
	Receive "length" number of bytes of data from the device at "device_address" on bus "bus".\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\i\b \cf0 The following Smbus functions return unsupported for now due to lack of bus driver support-
\i0\b0 \
\
hw.smbus.quick_write (bus,device_address)\
	bus: positive integer\
	device_address: positive integer\
	Execute a zero-byte write of the device at "device_address".\
\
hw.smbus.read_byte (bus,device_address, register_address)\
	bus: positive integer\
	device_address: positive integer\
	register_address_size: positive integer\
	Read a byte from the register specified by "register_address" from the device at "device_address" on bus "bus".\
\
hw.smbus.read_word (bus,device_address, register_address)\
	bus: positive integer\
	device_address: positive integer\
	register_address_size: positive integer\
	Read 2 bytes from the register specified by "register_address" from the device at "device_address" on bus "bus".\
\
hw.smbus.write_byte (bus,device_address, register_address,data)\
	bus: positive integer\
	device_address: positive integer\
	register_address_size: positive integer\
	data: string\
	Write a byte into the register specified by "register_address" in the device at "device_address" on bus "bus".\
\
hw.smbus.write_word (bus,device_address, register_address,data)\
	bus: positive integer\
	device_address: positive integer\
	register_address_size: positive integer\
	data: string\
	Write 2 bytes into the register specified by "register_address" in the device at "device_address" on bus "bus".\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b\fs26 \cf0 UART Access
\b0\fs24 \
\
hw.uart.flush_tx (uart_port)\
	uart_port: positive integer\
	Reset the uart  tx port of UART specified by "uart_port".\
\
hw.uart.flush_rx (uart_port)\
	uart_port: positive integer\
	Reset the uart  rx port of UART specified by "uart_port".\
\
default = hw.uart.get_control(uart_port)\
	uart_port: positive integer\
	default: table\
	Get the current Control mask of the UART specified by "uart_port" and store in table "default".\
\
hw.uart.set_control(uart_port, control_mask)\
	uart_port: positive integer\
	control_mask: table\
	Set the current Control Mask of the UART specified by "uart_port" with the  values in the table "control_mask".\
\
hw.uart.send (uart_port, data,length)\
	uart_port: positive integer\
	data: table\
	length: positive integer\
	Write data specified by "data" into the UART specified by "uart_port".\
\
data = hw.uart.receive (uart_port,length)\
	uart_port: positive integer\
	length: positive integer\
          data: table\
	Read  "length" number of bytes from the UART specified by "uart_port"  into "data".\
\
hw.uart.set_configuration(uart_port, control_parameters)\
	uart_port: positive integer\
	control_parameters: table\
	Configure the various attributes of the UART specified by "uart_port" using the table "control_parameters" (timeout,,timeout,baud rate,receivedepth,paity,databits,stopbits). If 	nothing is passed in, the current value will be retained.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\i\b \cf0 The following Uart functions return unsupported for now due to lack of bus driver support-\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\i0\b0 \cf0 \
default = hw.uart.get_configuration(uart_port)\
	uart_port: positive integer\
	default: table\
	Get the current configuration of the UART specified by "uart_port" and store it in the table "default".\
\
hw.uart.get_rxfifo_size(uart_port)\
	uart_port: positive integer\
	Get the number of bytes left to receive on the particular UART specified by "uart_port".\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b\fs26 \cf0 SPI Access
\b0\fs24 \
\
hw.spi.send (channel,data,length)\
	channel: positive integer\
	data: table\
	Send data passed in through "data", on the spi bus specified by "channel".\
\
hw.spi.receive (channel,length)\
	channel: positive integer\
	length: positive integer\
	Receive "length" number of bytes on the spi bus specified by "channel".\
\
hw.spi.set_configuration (channel,clock,mode)\
	channel: positive integer\
	clock: positive integer\
	mode: table \
	Set the clock value specified by "clock"  and the mode configuration in "mode" on the spi bus specified by "channel" .\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\i\b \cf0 The following Spi functions return unsupported for now due to lack of bus driver support-\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\i0\b0 \cf0 \
clock =hw.spi.get_configuration (channel)\
	clock: positive integer\
	channel: positive integer\
	Read the current clock value into "clock"  on the spi bus specified by "channel" .\
\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b\fs26 \cf0 Memory Access
\b0\fs24 \
\
hw.mem.read (address, width) \
	address: positive integer\
	width: positive integer\
\
hw.mem.write (address, width, value) \
	address: positive integer\
	width: positive integer\
	value: string\
\
hw.mem.fifo_read (address,width,count)\
	address: positive integer\
	width: positive integer\
	count: positive integer\
	Reads the FIFO register of  width specified by "width" at address  specified by "address" for "count" number of times. It repeatedly reads the same FIFO register.\
\
hw.mem.fifo_write (address,width,data,count)\
	address: positive integer\
	width: positive integer\
	count: positive integer\
	data: string\
	Writes the FIFO register of  width specified by "width" at address  specified by "address" for "count" number of times with "data". It repeatedly writes the same FIFO register with 	the same data.\
\

\b\fs26 Gpio Access\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b0\fs24 \cf0 hw.gpio.set_output (port, pin,value) \
	port: string\
	pin: positive integer\
	value: positive integer
\b\fs26 \
\

\b0\fs24 hw.gpio.set_input (port, pin) \
	port: string\
	pin: positive integer
\b\fs26 \

\b0\fs24 \
hw.gpio.set_pullup (port, pin) \
	port: string\
	pin: positive integer\
\
hw.gpio.set_pulldown (port, pin) \
	port: string\
	pin: positive integer\
\
hw.gpio.set_nopull (port, pin) \
	port: string\
	pin: positive integer\
\
value = hw.gpio.get (port, pin) \
	port: string\
	pin: positive integer\
	value: positive integer\
\
hw.gpio.set_function (port, pin,value) \
	port: string\
	pin: positive integer\
	value: positive integer\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b\fs26 \cf0 Helper Functions\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\b0\fs24 \cf0 value = hw.helper.reverse (data, length) \
	data: positive integer\
	length: positive integer\
	value: positive integer\
	Swap "length" number of bytes in "data". "length" can be 1,2,4. 1 is equivalent to the original number, 2 swaps lower 2 bytes of data in the number and leaves the upper 2 bytes as such. 4 swaps all 4 bytes in the number and store it in "value".\
\
value = hw.helper.cpu_to_be16(data)\
	data: positive integer\
	value: positive integer\
	Convert the 16 bit number "data" to Big Endian format and store it in "value".\
\
value = hw.helper.cpu_to_be32(data)\
	data: positive integer\
	value: positive integer\
	Convert the 32 bit number "data" to Big Endian format and store it in "value".\
\
value = hw.helper.cpu_to_le16(data)\
	data: positive integer\
	value: positive integer\
	Convert the 16 bit number "data" to Little Endian format and store it in "value".\
\
value = hw.helper.cpu_to_le32(data)\
	data: positive integer\
	value: positive integer\
	Convert the 32 bit number "data" to Little Endian format and store it in "value".\
\
value = hw.helper.be16_to_cpu(data)\
	data: positive integer\
	value: positive integer\
	Convert the 16 bit number "data" in Big Endian format to the native format of the CPU and store it in "value".\
\
value = hw.helper.be32_to_cpu(data)\
	data: positive integer\
	value: positive integer\
	Convert the 32 bit number "data" in Big Endian format to the native format of the CPU and store it in "value".\
\
value = hw.helper.le16_to_cpu(data)\
	data: positive integer\
	value: positive integer\
	Convert the 16 bit number "data" in Little Endian format to the native format of the CPU and store it in "value".\
\
value = hw.helper.le32_to_cpu(data)\
	data: positive integer\
	value: positive integer\
	Convert the 32 bit number "data" in Little Endian format to the native format of the CPU and store it in "value".\
}