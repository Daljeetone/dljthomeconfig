%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Vim settings                                                             %%
%%    set noexpandtab                                                       %%
%%    set spell spelllang=en spellfile=SmokeyManual.en.utf-8.add            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include {ConsoleBase}
\begin{document}

%\addtolength{\parskip}{0.9mm}
\newgeometry{top=\TopMargin, bottom=\BottomMargin, hmargin=\TransverseMargin}
%\setlength{\parskip}{10pt}

\begin{titlepage}

\setlength{\parindent}{0in}

{
	\fontsize{32}{32}\selectfont
	\textcolor{AppleGray}{\AppleLogo}
}
\\[0.25in]

{
    \begin{spacing}{1.0}
	\fontsize{32}{32}\selectfont 
	\textcolor{SmokeyDarkBlue}{\bfseries Console Framework} \\
	\textbf{User Guide} \\ 
    \end{spacing}
}

June 11\textsuperscript{th} 2014
\\[0.25in]

Jerry Johns \\
System Software Engineering - Firmware \\
\small\texttt{jjohns@apple.com}

\vfill

\begin{center}
Apple Confidential --- DO NOT DISTRIBUTE
\end{center}

\end{titlepage}

\clearpage
\fancyhfoffset[r]{0in}
\pagenumbering{gobble}

\setcounter{tocdepth}{4}
\tableofcontents

\clearpage
\fancyhfoffset[l]{\BodyIndentLeft}
\fancyhfoffset[r]{0in}
% TODO: Why does using \restoregeometry instead of \newgeometry cause the
% following pages to shift downards?
%\restoregeometry
\newgeometry{top=\TopMargin, bottom=\BottomMargin, left=\LeftMargin, right=\TransverseMargin}
\pagenumbering{arabic}

\section{Introduction}

\subsection{What is this about?}

The console framework sits at the heart of EFI and manages all console traffic
that gets generated in the system. This framework was recently over-hauled and introduces
a wealth of functionality that is beneficial to both developers and users alike. This document aims to educate them on utilizing 
its many features effectively when interacting with Diags.

\subsection{Audience}

This document is intended for anyone who interacts with Diags both at the shell prompt as 
well as through the Smokey scripting framework.

\subsection{Document Objective}

This document will provide relevant technical details and concepts introduced in the 
new framework. It will also provide command usage guidelines and a set of workflows that are useful to most users 
working in EFI.

\section {Framework Design}

This section will focus on the design of the console framework and introduce
key concepts needed to become productive with the new console commands. 

\subsection{Sources/Sinks}

The console framework introduces a concept of sources and sinks that define granular boundaries 
for entities governing text production and consumption.

\begin{Definition}
	\item[Source] A unique, addressable entity that produces text
    \item[Sink] A unique, addressable entity that consumes text. Examples of sinks include \cmdline{smokey}, \cmdline{serial} 
        and \cmdline{filelog}
    \item[Console Router] Routes text from sources to sinks based on configurable route tables
    
\end{Definition}

Every driver in the system is setup by default to be a unique source.

\subsection{Text Types}

The framework standarizes the types of text that can be generated by a source. This allows 
for type-specific actions/formatting to be effected without heuristic inferrance from the text.

\begin{ValueTable}
\bfseries Type & \bfseries Definition \\ \hline
	Print & Normal operational text \\
    Error & Critical failure \\ 
    Warning & Not an error, indication something may be wrong with the system \\ 
    Debug & Useful debugging output, provides more insight\\ 
    Trace & Function entry/exit + custom breadcrumb markers \\
\end{ValueTable}

\subsubsection{Debug Type}

The debug text type is slightly different from the rest - each source can export a set of named debug bit masks 
that fall under this type category. This allows for each source to granularize the various kinds of debug spew
it can generate. 

As an example, a codec driver might export two debug bit masks - one named \prop{transactions} for all register
reads/writes to the chipset, and another called \prop{volumes} that provides debug spew when setting/getting volumes 
on the part. These provide two different views into what's happening on the codec. When debugging a volume 
issue, you can start by enabling the \prop{volumes} mask. If that doesn't get you far enough, you can then enable 
the \prop{transactions} mask as well to get more information.

\subsubsection{Global Debug}

With the plethora of sources and their associcated debug bit masks in the system, it might be tough to quickly narrow 
down the source for which you'd like to enable verbosity. The global debug container attempts to solve that problem by allowing 
every source to optionally map a subset of their registered debug bit masks against this umbrella container. This allows consumers to quickly enable 
a minimal amount of trace in the system and get a more detailed view of underlying operations before narrowing down their 
investigation. 

\subsection{Routing}

The console router exposes the ability for consumers to selectively add or delete routes from any source to any sink.
Granularity is provided at the source's text type level. Hence, you can effect routing changes to a
type of text generated by a specific source without changing routes for any of its other text types.

The router also provides a mask/unmask feature --- this can be thought of as a temporary mute to disable any text generation
or reception at a source/sink. 

\subsection{Tagged Text}

Alongside text produced by a source, meta-data is appended to the text that travels alongside till the final destination. 
This includes information such as timestamp, text type, function name and source name.

\subsection{Forensics}

The framework houses a forensics buffer that automatically captures certain kinds of text without user intervention. This is meant 
to aid debugging failures by providing a slightly more detailed view of what transpired without needing to re-run the tests. 

By default, all prints, errors, warnings and global debug prints are stored in the forensics buffer.

\subsection{Boot Configuration}

Most diags distributions are bundled with a few stock sinks. These include:

\begin{Definition}
\item[serial] Sinks text that is destined for all console-based mediums. This includes UART, USB CDC and SWD
\item[smokey] Sink for the Smokey LUA sequencer
\item[ramlog] Sink for capturing text to RAM
\item[filelog] Sink for capturing text to a file
\end{Definition}

Routes for prints, errors and warnings have been added from all sources to the serial sink by default on release builds. 

In addition to the above, debug builds have routes setup from every source's debug masks (that map to the global debug container) routed to the \cmdline{serial} sink.

\section{Command Usage}

This section outlines the various console commands and their usage. 

\subsection{``consolerouter'' command}

This command manages the router at the heart of the framework, allowing for effecting routing/masking changes. It also controls 
dumping of the forensics buffer. 

\subsubsection{Source Listing}

To list the various sources present in the system:

\begin{CommandLine}
consolerouter --listsources
\end{CommandLine}

This list is divided into two sections. The first set of sources (labelled \cmdline{legacy sources}) denotes sources that have yet to 
register against the new framework. This means that they won't have any debug masks exported. It also means that they are named after the EFI driver.

\begin{LuaCode}
~\hl:-) consolerouter --listsources ~
>>> Legacy sources:

DiagShell
AppleBarcode
AppleDiagsSecurityManager
DisplayConsole
TestNvram
ControlBitsIPX
MCATransport
MCA
AppleSimpleUsbFs
DfuImageManagement
\end{LuaCode}

The second set (labelled \cmdline{registered sources}) have been explicitly registered with the console framework. They can optionally have debug masks registered against the console framework. 

It is possible to have both registered and legacy sources for the same image.

\begin{LuaCode}
>>> Registered sources:

gyro:
    image: AP3GDL
    debug-bits:
        reg-ops: Register operations (read and write)
        data: Gyro data

i2clib:
	image: ALS, PmuCore, Codec 
	debug-bits:
		type : Information on packet types + sizes
		pktdata : Packet data
\end{LuaCode}

The \cmdline{debug-bits} field list the various debug masks available for a particular source. 

The \cmdline{image} field lists the driver image that this source is registered against. 
This is useful in the case of libraries (like \cmdline{i2clib} above) that gets used by multiple images. 
In the above case, the \cmdline{ALS}, \cmdline{PMUCore} and \cmdline{Codec} drivers have registered the \cmdline{i2clib} source. 

\subsubsection{Sink Listing}

To list the various console sinks present in the system:

\begin{CommandLine}
consolerouter --listsinks
\end{CommandLine}

The sink listing looks a lot simpler and provides a name and description for each sink registered 
in the system:

\begin{LuaCode}
~\hl:-) consolerouter --listsinks ~
serial:
	description: Console sink that routes/formats text for serial output over UART/USB
file:
	description: Console sink that stores console output to a file
ramlog:
	description: Sink that can be used to specifically log specific
    text to RAM
OK
\end{LuaCode}

\subsubsection{Routing}

To route text:

\begin{CommandLine}
consolerouter [--add | --rm] --src source_specifier --dest sink_specifier
\end{CommandLine}

The \cmdline{source\_specifier} has to be provided in the following form:

\begin{center}
    \bfseries{source.text-type.debug-mask}
\end{center}


\begin{Definition}
\item[source] Name of text generating entity (e.g \cmdline{PmuCore}, \cmdline{i2clib} or \cmdline{system})
\item[text-type] Type of text. The acceptable types are:
    \begin{itemize} \parskip0pt
        \item error
        \item print 
        \item warn 
        \item trace 
        \item debug
    \end{itemize}
\item[debug-mask] Debug mask. This field is only applicable when specifying \cmdline{debug} for text-type 
\end{Definition}

Here are some examples of source specifiers:

\begin{SrcSpecifierTable}
    PmuCore.error& All errors from the \cmdline{PmuCore} source\\ 
    i2clib.debug.pktdata & All debug text of mask \cmdline{pktdata} from the \cmdline{i2clib} source\\ 
\end{SrcSpecifierTable}

\bigskip
Wildcards are also supported. The \cmdline{*} character selects all within the specifier sub-type.

\begin{SrcSpecifierTable}
    PmuCore.* & All text types from the \cmdline{PmuCore} source\\
    \**.error & Errors from all sources\\ 
    i2clib.debug.* & All debug prints from the \cmdline{i2clib} source\\ 
    \** & All text from all sources\\
\end{SrcSpecifierTable}
\bigskip 

To facilitate convenience of entry, braces and commas can be used to allow for cartesian-product expansion:

\begin{SrcSpecifierTable}
    \{PmuCore,i2clib\}.* & All text types from the \cmdline{PmuCore} and \cmdline{i2clib} sources\\ 
    i2clib.\{error,warn\} & All errors and warnings from \cmdline{i2clib}\\ 
    \{PmuCore,system\}.\{error,warn\} & All errors and warnings from \cmdline{PmuCore} and \cmdline{system}\\
    i2clib,PmuCore.\{error,warn\} & All prints from \cmdline{i2clib} + errors, warnings from \cmdline{PmuCore}\\ 
\end{SrcSpecifierTable}
\bigskip 

The \cmdline{sink-specifier} also support wildcard specifiers, commas and brace expansion:

\begin{SrcSpecifierTable}
    serial & \cmdline{serial} sink\\
    \** & All sinks\\ 
    serial,smokey & \cmdline{smokey} and \cmdline{serial} sinks\\ 
    s\{erial,mokey\} & \cmdline{smokey} and \cmdline{serial} sinks\\
\end{SrcSpecifierTable}

\subsubsection{Masking}

Masking/Unmasking allows the user to temporarily mute/un-mute both sources and sinks.  For sources, you can effect masking changes at the text type level. For sinks, you can effect masking changes at the sink level. 

\begin{CommandLine}
consolerouter [--mask | --unmask] [--src source_specifier] [--dest sink_specifier]
\end{CommandLine}

E.g:

\begin{SrcSpecifierTable}
    --mask --src system & Masks all routes emnating from the \cmdline{system} source \\
    --mask --src PmuCore.error & Masks routes of error type emnating from \cmdline{PmuCore} \\
    --mask --src PmuCore.\{error,warn\} & Masks routes of error + warn type emnating from \cmdline{PmuCore} \\
    --mask --desk smokey & Masks all routes going to the \cmdline{smokey} sink \\
    --mask --dest serial & Masks all routes going to the \cmdline{serial} sink \\
\end{SrcSpecifierTable}
\bigskip 

The masking operation has no effect on the routes themselves.

\subsubsection{Forensics Buffer}

This command provides the ability to dump out the forensics buffer. You can provide an optional argument to limit the spew to a specific number of commands executed at the shell.

\begin{CommandLine}
consolerouter --dump [num-commands]
\end{CommandLine}

Dumping the entire buffer:

\begin{LuaCode}
~\hl:-) consolerouter --dump ~
Dumping forensics buffer...
|| Console router buffer allocated @ 0x83E17C018, size = 262144 bytes
|| [system.error] Installed soc embedded gpio
|| [system.error] !!!!!!!!!!!!!!!!!!!!!!UDR: 0x5A6E4C70A3823017, BaseVdd: 600
|| [system.error] Came to install McaAudioTransportExsoc PMGR installed
|| [system.debug] [DPM:InitializeDomainManagement] Device: 1
|| [system.debug] [DPM:InitializeDomainManagement] Device: 2
|| [system.debug] [DPM:InitializeDomainManagement] Device: 3
|| [system.debug] [DPM:InitializeDomainManagement] Device: 5
|| [system.debug] [DPM:InitializeDomainManagement] Device: 6
|| [system.debug] [DPM:InitializeDomainManagement] Device: 7
|| [system.debug] [DPM:InitializeDomainManagement] Device: 26
|| [system.debug] [DPM:InitializeDomainManagement] Marking 26
\end{LuaCode}

Dumping just the last command's output:

\begin{LuaCode}
~\hl:-) sensor -s als --init ~
Turning off power to 'als' sensor...
Turning on power to 'als' sensor...
Resetting 'als' sensor...
OK
~\hl:-) consolerouter --dump 1 ~
Dumping forensics buffer...
Dumping the last 1 commands' outputs...
|| :-) sensor -s als --init
|| Turning off power to 'als' sensor...
|| [system.debug] Power off sequence for Bus:2, Addr:0x29

|| [system.debug] Write Control byte

|| [system.debug] Disable interrupt

|| Turning on power to 'als' sensor...
|| [system.error] Locating ALS device...
|| [system.error] Locate ALS:Dev ID reg val:0x92
|| [system.debug] Gain set to 1 

|| Resetting 'als' sensor...
|| OK
|| :-) consolerouter --dump 1
|| Dumping forensics buffer...
|| Dumping the last 1 commands' outputs...
Done dumping!
OK
:-) 
\end{LuaCode}

\subsection{``consoleformat'' command}

The ``consoleformat'' command handles setting/getting formatting options for console-based mediums (like \cmdline{serial}, \cmdline{smokey} and \cmdline{file} sinks). 

\subsubsection{Sink Listing}

To list all serial-based sinks:

\begin{CommandLine}
consoleformat --listsinks
\end{CommandLine}

Output:

\begin{LuaCode}
~\hl:-) consoleformat --listsinks ~
file:
	display-options: 
serial:
	display-options: color
OK
\end{LuaCode}

The currently enabled formatting options for each sink is provided in the listing as well. 

\subsubsection{Formatting Options}

To set formatting:

\begin{CommandLine}
consoleformat --sink sink-name [--en|--dis] --options [func,source,ts,color]
\end{CommandLine}

Option Description:

\begin{FormatOptionSpecifierTable}
    func & Function name \\
    source & Source name (e.g \cmdline{i2clib} or \cmdline{PmuCore}) \\
    ts & Timestamp \\
    color & Text color \\
\end{FormatOptionSpecifierTable}

Multiple options can be passed in together in a comma delimited list:

\begin{CommandLine}
consoleformat --sink serial [--en|--dis] --options func,source
\end{CommandLine}

Formatting options can vary from sink to sink. 

\subsubsection{Formatted Output}

When formatting options are enabled, text is formatted in a very specific manner:

\begin{ColorOptionsTable}
    no formatting & Hello World! \\ \hline
    + source & [system] Hello World! \\
            & [PmuCore:i2clib] Hello World! \\
            & [PmuCore:i2clib.debug.pktdata] Hello World! \\ \hline
    + function name & [PrintHelloWorld] Hello World! \\ \hline
    + timestamp & <1843.890109s (+2.205379)> Hello World! \\
              & <1843.890111s (+0.000002)> Hello World! \\
\end{ColorOptionsTable}

When \cmdline{source} is enabled, it can be printed in a few different ways (see above). Most prints appear in the first 
fashion. When printing from a library (like \cmdline{i2clib}), the console provides the driver name as well (i.e \cmdline{PmuCore:i2clib}).
Finally for debug prints, the debug mask is also displayed to the user. 

All three formatting options enabled (\cmdline{source}, \cmdline{func} and \cmdline{ts}):

\begin{LuaCode}
[system :: PrintHelloWorld <1843.890109s (+2.205379)>] Hello World!
[PmuCore:i2clib :: PrintHelloWorld <1843.890109s (+2.205379)>] Hello World!
[PmuCore:i2clib.debug.pktdata :: PrintHelloWorld <1843.890109s (+2.205379)>] Hello World!
\end{LuaCode}

When color is enabled, ANSI color codes are injected into the text stream along with a custom prefix string:

\begin{ColorOptionsTable}
    errors & \textcolor{red}{ERROR: Did not initialize!} \\ \hline
    warnings & \textcolor{pink}{WARNING: Potential clock violation!} \\ \hline
    debug & \textcolor{yellow}{[system.info] Potential clock violation!} \\ \hline
    trace & \textcolor{blue}{TRACE: Entered function!} \\
\end{ColorOptionsTable}

\subsection{``ramlog'' command}

The \cmdline{ramlog} sink allows users to route desired prints to RAM without incurring 
the overhead of printing to serial. This allows for capturing prints that otherwise would affect behaviour if routed to serial. 

Note that a route has to be setup to this sink for it to capture text.

\subsubsection{Initialization/Teardown}

The following options control initialization and teardown of the ramlog sink:

\begin{CommandLine}
ramlog [--on size_in_megabytes] [--off]
\end{CommandLine}

\subsubsection{Pause/Un-pause}

The ramlog can be momentarily paused/un-paused as the user sees fit - the contents in RAM remain unaltered and no text is sent to the 
sink during this window

\begin{CommandLine}
ramlog [--pause] [--unpause]
\end{CommandLine}

\subsubsection{Clear}

The contents in the ramlog can be cleared without affecting logging functionality. 

\begin{CommandLine}
ramlog --clear
\end{CommandLine}

\subsubsection{Over-write}

By default, the ramlogger will continue to capture text when the buffer gets full by over-writing the most stale entries. 

To stop the ramlogger from logging any further once it is full:

\begin{CommandLine}
ramlog --on [--stoponfull]
\end{CommandLine}

The \cmdline{--stoponfull} option should only be used with the \cmdline{--on} option. 

\subsection{``filelog'' command}

The \cmdline{file} sink allows users to route desired prints to file.

Note that a route has to be setup to this sink for it to capture text.

\subsubsection{Initialization/Teardown}

The following options control initialization and teardown of the filelog sink:

\begin{CommandLine}
filelog [--on path_to_file] [--off]
\end{CommandLine}

Due to performance considerations, text is buffered inside the file logger and flushed to file when a certain number of bytes have accumulated. When the filelogger is turned off, all remaining bytes in the buffer are flushed out. 

\subsection{``debug'' command}

This command enables/disables global debug prints in the system. Specifically, it adds/removes global debug routes from all sources to the \cmdline{serial} sink. Hence, this command 
has no effect on routes to other sinks like \cmdline{smokey} or \cmdline{ramlog}. 

\begin{CommandLine}
debug [--on | --off]
\end{CommandLine}

\section{Common Workflows}

To help users get the most out of the new features in the console framework, a few real-world workflows have been provided in this section that best leverage the new feature-set.

\subsection{``What just happened?''}

\bfseries Scenario:

\mdseries A command just failed and you'd like to know a bit more about what transpired leading up to the event.

\begin{LuaCode}
~\hl:-) device -k GasGauge -e log\_on fast ~
enabling auto-calibration mode
ERROR: Method "log_on" returned status Device Error
device returned Device Error error
\end{LuaCode}

\bfseries Solution:

\mdseries You can use the forensics buffer to dump out additional debug information that may have been logged in the background while that command was running:

Just dump out the contents of forensics buffer for the last command:

\begin{LuaCode}
~\hl:-) consolerouter --dump 1 ~
Dumping forensics buffer...
Dumping the last 1 commands' outputs...
|| [001A59C0:2403C13A] :-) device -k GasGauge -e log_on fast
|| [gasgauge.info] Waiting for CCA to finish...
|| [gasgauge.trans] Reading control: data-type = 0000, length = 2, needs_unseal = no
|| [gasgauge.info] Unsealing...
|| [gasgauge.info] Status Reg = 0x0B 0x60
|| [gasgauge.info] IsSealed = SEALED
|| [gasgauge.info] Status Reg = 0x0B 0x40
|| [gasgauge.info] IsSealed = SEALED
|| [gasgauge.info] Unseal failed. Retrying...
|| [gasgauge.info] Status Reg = 0x0B 0x40
|| [gasgauge.info] IsSealed = SEALED
|| [gasgauge.info] Unseal failed. Retrying...
|| [gasgauge.info] Status Reg = 0x0B 0x40
|| [gasgauge.info] IsSealed = SEALED
|| [gasgauge.info] Unseal FAIL
|| enabling auto-calibration mode
|| ERROR: Method "log_on" returned status Device Error
|| device returned Device Error error
|| [001A59C0:2403C13A] :-) consolerouter -t 1
|| Dumping forensics buffer...
|| Dumping the last 1 commands' outputs...
Done dumping!
OK
\end{LuaCode}

In this case, the gas gauge driver failed to start logging because the unseal operation failed. You also know exactly how many attempts were made, and the 
register contents of the status register during each of those attempts. You might want to then enable more verbosity within the gas gauge 
driver to further debug this issue. 

Perhaps at this point, you'd like to get a sense for which functions/sources generated this error. You can do this by re-unrolling the forensics buffer with additional 
formatting options put in place:

\begin{LuaCode}
~\hl:-) consoleformat --sink serial --en --options func,source ~
Enabling function-name option...
[_BraceExprCallback] Enabling source option...
[TestConsole :: EblConsoleFormatCmd] OK 
~\hl:-) consolerouter --dump 1 ~
[TestConsole :: EblConsoleRouterCmd] Dumping forensics buffer...
[TestConsole :: EblConsoleRouterCmd] Dumping the last 1 commands' outputs...
|| [001A59C0:2403C13A] :-) device -k GasGauge -e log_on fast
|| [gasgauge.info :: InternalWaitOnCCAClear] Waiting for CCA to finish...
|| [gasgauge.trans :: Read] Reading control: data-type = 0000, length = 2, needs_unseal = no
|| [gasgauge.info :: DoUnseal] Unsealing...
|| [gasgauge.info :: IsSealed] Status Reg = 0x0B 0x60
|| [gasgauge.info :: IsSealed] IsSealed = SEALED
|| [gasgauge.info :: IsSealed] Status Reg = 0x0B 0x40
|| [gasgauge.info :: IsSealed] IsSealed = SEALED
|| [gasgauge.info :: DoUnseal] Unseal failed. Retrying...
|| [gasgauge.info :: IsSealed] Status Reg = 0x0B 0x40
|| [gasgauge.info :: IsSealed] IsSealed = SEALED
|| [gasgauge.info :: DoUnseal] Unseal failed. Retrying...
|| [gasgauge.info :: IsSealed] Status Reg = 0x0B 0x40
|| [gasgauge.info :: IsSealed] IsSealed = SEALED
|| [gasgauge.info :: DoUnseal] Unseal FAIL
| [gasgauge.info :: DoSeal] Already Sealed
|| [TestDevice :: EblDevice] ERROR: Method "log_on" returned status Device Error
|| device returned Device Error error
\end{LuaCode}

\subsection{``What's happening in this command?''}

\bfseries Scenario:

\mdseries You want to get more insight into what's happening in a particular command, or driver. 

\begin{LuaCode}
~\hl:-) device -k GasGauge -e log\_on fast~
enabling auto-calibration mode
ERROR: Method "log_on" returned status Device Error
device returned Device Error error
\end{LuaCode}

\bfseries Solution:

\mdseries Building on the same example we had used for the previous scenario, let's assume in this case that we gleaned very little from the forensics buffer. 

\subsubsection{Deduce Source}

To delve further into the above failure, we need to know which debug sources to enable. You might know this 
apriori: in the above case, it would be \cmdline{gasgauge} and \cmdline{uartswif} console sources. 

If you don't know them ahead of time, run:

\begin{CommandLine}
debug --on
\end{CommandLine}

This will enable a sparse level of debug on most sources in the system. 

In addition, enable source name in the format options:

\begin{CommandLine}
consoleformat --sink serial --en --options source
\end{CommandLine}

Now, rerun the same command:

\begin{LuaCode}
~\hl:-) device -k GasGauge -e log\_on fast ~
[gasgauge.info :: InternalWaitOnCCAClear] Waiting for CCA to finish...
[gasgauge.trans :: Read] Reading control: data-type = 0000, length = 2, needs_unseal = no
[gasgauge.info :: DoUnseal] Unsealing...
[gasgauge.info :: IsSealed] Status Reg = 0x0B 0x40
[gasgauge.info :: IsSealed] IsSealed = SEALED
[gasgauge.info :: IsSealed] Status Reg = 0x0B 0x40
[gasgauge.info :: IsSealed] IsSealed = SEALED
[gasgauge.info :: DoUnseal] Unseal failed. Retrying...
[gasgauge.info :: IsSealed] Status Reg = 0x0B 0x40
[gasgauge.info :: IsSealed] IsSealed = SEALED
[gasgauge.info :: DoUnseal] Unseal failed. Retrying...
[gasgauge.info :: IsSealed] Status Reg = 0x0B 0x40
[gasgauge.info :: IsSealed] IsSealed = SEALED
[gasgauge.info :: DoUnseal] Unseal FAIL
[TestDevice :: EblDevice] ERROR: Method "log_on" returned status Device Error
device returned Device Error error
\end{LuaCode}    

Aha! We now know some additional information (looks like unseal failed) as well as the source of the offending error
(\cmdline{gasgauge})

\subsubsection{Enable Debug Masks}

Let's see if we can get some additional information out of this source. Start by checking to see if this particular source 
has debug flags registered:

\begin{LuaCode}
~\hl:-) consolerouter --listsources ~
...
...
...
gasgauge:
	image: BQ27541
	debug-bits:
		info : General informational prints
		trans : Information on command/data reads/writes
		data : Actual byte data over UART SWIF
uartswif:
	macho: UartSwif
	bit-masks:
		data : Raw data
\end{LuaCode}

Looks like the \cmdline{gasgauge} source has three masks defined. In addition, we know that this driver consumes services from another source, 
the \cmdline{uartswif} source. We can first enable extra debugging in the \cmdline{gasgauge} source, and if that doesn't suffice, enable 
debugging on the \cmdline{uartswif} source. 

\begin{LuaCode}
~\hl:-) consolerouter --add --src gasgauge.debug --dest serial ~
Routing DEBUG (0x00000007): 'gasgauge' -> 'serial'
OK
~\hl:-) device -k GasGauge -e log\_on fast ~
[gasgauge.info] Waiting for CCA to finish...
[gasgauge.trans] Reading control: data-type = 0000, length = 2, needs_unseal = no
[gasgauge.data] <= HDQ_WRITE: Cmd = 00, Data = 00
[gasgauge.data] <= HDQ_WRITE: Cmd = 01, Data = 00
[gasgauge.data] => HDQ_READ: Cmd = 00, Data = 0B
[gasgauge.data] => HDQ_READ: Cmd = 01, Data = 40
[gasgauge.info] Unsealing...
[gasgauge.data] <= HDQ_WRITE: Cmd = 00, Data = 00
[gasgauge.data] <= HDQ_WRITE: Cmd = 01, Data = 00
[gasgauge.data] => HDQ_READ: Cmd = 00, Data = 0B
[gasgauge.data] => HDQ_READ: Cmd = 01, Data = 40
[gasgauge.info] Status Reg = 0x0B 0x40
[gasgauge.info] IsSealed = SEALED
[gasgauge.data] <= HDQ_WRITE: Cmd = 00, Data = 36
[gasgauge.data] <= HDQ_WRITE: Cmd = 01, Data = 12
[gasgauge.data] <= HDQ_WRITE: Cmd = 00, Data = 44
[gasgauge.data] <= HDQ_WRITE: Cmd = 01, Data = 65
[gasgauge.data] <= HDQ_WRITE: Cmd = 00, Data = 00
[gasgauge.data] <= HDQ_WRITE: Cmd = 01, Data = 00
[gasgauge.data] => HDQ_READ: Cmd = 00, Data = 0B
[gasgauge.data] => HDQ_READ: Cmd = 01, Data = 40
[gasgauge.info] Status Reg = 0x0B 0x40
[gasgauge.info] IsSealed = SEALED
[gasgauge.info] Unseal failed. Retrying...
...
...
...
\end{LuaCode}

We find out all the registers that the driver is writing/reading to/from when enabling logging.

Perhaps this isn't enough information - let's enable the \cmdline{uartswif} data as well:

\begin{LuaCode}
~\hl:-) consolerouter -a -s uartswif.debug --dest serial ~
Routing debug (0x00000001): 'uartswif' -> 'serial'
OK
~\hl:-) device -k GasGauge -e log\_on fast ~
[gasgauge.info] Waiting for CCA to finish...
[gasgauge.trans] Reading control: data-type = 0000, length = 2, needs_unseal = no
[gasgauge.data] <= HDQ_WRITE: Cmd = 00, Data = 00
[uartswif.data] Sending break...
[uartswif.data] Writing 2 bytes: 0x80 0x00
[uartswif.data] Read 2 bytes: 0x80 0x00 
[gasgauge.data] <= HDQ_WRITE: Cmd = 01, Data = 00
[uartswif.data] Sending break...
[uartswif.data] Writing 2 bytes: 0x81 0x00
[uartswif.data] Read 2 bytes: 0x81 0x00 
[gasgauge.data] => HDQ_READ: Cmd = 00, Data = 
[uartswif.data] Sending break...
[uartswif.data] Writing 1 bytes: 0x00 Read 1 bytes: 0x00 
[uartswif.data] Read 1 bytes: 0x0B 
[gasgauge.data] 0B
[gasgauge.data] <= HDQ_WRITE: Cmd = 00, Data = 00
[uartswif.data] Sending break...
[uartswif.data] Writing 2 bytes: 0x80 0x00
[uartswif.data] Read 2 bytes: 0x80 0x00 
...
...
...
\end{LuaCode}

By enabling debug from the various sources that make up a command, we're able to unlock successively richer views of information 
from the underlying code. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{``Enabling prints causes the problem to go away...''}

\bfseries Scenario: \mdseries\par
A failing command suddenly passes when I enable debug prints. 

\bfseries Solution: \mdseries\par
Route those debug prints to the \cmdline{ramlog} sink so that they won't affect timing. 

Building on top of the scenario above, we can route all the additional debug prints from the \cmdline{gasgauge} and \cmdline{uartswif} 
sources to the \cmdline{ramlog} sink and view them after. 

\begin{AnnotedLogFile}
~\mp{Initial Output}~~\hl:-) device -k GasGauge -e log\_on ~
enabling auto-calibration mode
ERROR: Method "log_on" returned status Device Error
device returned Device Error error
~\mp{Setup Routes}~~\hl:-) consolerouter --add --src gasgauge.debug,uartswif.debug --dest ramlog ~
Routing DEBUG (0x00000007): 'gasgauge' -> 'ramlog'
Routing DEBUG (0x00000001): 'uartswif' -> 'ramlog'
OK
OK
~\mp{Enable Ramlog}~~\hl:-) ramlog --on 1 ~
Initializing ram logger to 1Mbytes...
Turning on logging...
~\mp{Re-run Command}~~\hl:-) device -k GasGauge -e log\_on ~
enabling auto-calibration mode
ERROR: Method "log_on" returned status Device Error
device returned Device Error error 
~\mp{Dump Ramlog}~~\hl:-) ramlog --dump ~
|| [gasgauge.info] Waiting for CCA to finish...
|| [gasgauge.type] Reading control data type 00 of length 2
|| [uartswif.data] Sending break...
|| [uartswif.data] Writing 2 bytes: 0x80 0x00
|| [uartswif.data] Read 2 bytes: 0x80 0x00 
|| [uartswif.data] Sending break...
|| [uartswif.data] Writing 2 bytes: 0x81 0x00
|| [uartswif.data] Read 2 bytes: 0x81 0x00 
|| [uartswif.data] Sending break...
|| [uartswif.data] Writing 1 bytes: 0x00 Read 1 bytes: 0x00 
|| [uartswif.data] Read 1 bytes: 0x0D 
|| [uartswif.data] Sending break...
~\mp{Enable Timestamps}~~\hl:-) consoleformat --dest serial --en --options ts ~
Enabling timestamps option...
<9293.526033s (+9293.526033)> OK
~\mp{Re-dump Ramlog}~~\hl:-) ramlog --dump ~
|| [gasgauge.info] <6.359588s (+2.385171)> Waiting for CCA to finish...
|| [gasgauge.type] <6.359598s (+0.000010)> Reading control data type 00, length 2
|| [uartswif.data] <6.359606s (+0.000008)> Sending break...
|| [uartswif.data] <6.359856s (+0.000250)> Writing 2 bytes: 0x80 0x00
|| [uartswif.data] <6.363186s (+0.003330)> Read 2 bytes: 0x80 0x00 
|| [uartswif.data] <6.363209s (+0.000023)> Sending break...
|| [uartswif.data] <6.363458s (+0.000249)> Writing 2 bytes: 0x81 0x00
|| [uartswif.data] <6.366789s (+0.003331)> Read 2 bytes: 0x81 0x00 
|| [uartswif.data] <6.366812s (+0.000023)> Sending break...
~\mp{Reset Routes to Default}~~\hl:-) consolerouter --reset  ~
<11932.553261s (+2635.923372)> Resetting routes and masks back to default...
<11932.561484s (+0.008223)> OK
\end{AnnotedLogFile}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{``What's happening in passthrough?''}

\bfseries Scenario: \mdseries\par
When doing passthrough (e.g wifi), you want to sniff and inspect the characters that were sent to/from the dock UART. 

\bfseries Solution: \mdseries\par
Route the correct \cmdline{serial} source's tx/rx debug masks to ramlog and run passthrough. 

\begin{AnnotedLogFile}
~\mp{Setup Route}~~\hl:-) consolerouter --add --src serial0 --dest ramlog ~
Routing all prints: 'serial0' -> 'ramlog'
OK
~\mp{Enable Ramlog}~~\hl:-) ramlog --on 1 ~
Initializing ram logger to 1Mbytes...
Turning on logging...
~\mp{Enter Passthrough}~~\hl:-) ramlog --wipe; wifi --passthrough ~
Wiping out contents in buffer...
OK
Entering pass-through mode (type "EXIT" to exit)...
~\mp{Exit Passthrough}~EXIT
:-)
~\mp{Dump Ramlog}~~\hl:-) ramlog --dump ~
|| [serial0.tx] 0x4F 0x4B 0x0A 0x45 0x6E 0x74 0x65 0x72 0x69 0x6E 0x67 0x20 0x70 
       0x61 0x73 0x73 0x2D 0x74 0x68 0x72 0x6F 0x75 0x67 0x68 
|| [serial0.rx] 0x06 0x01 0x00 0x00 0x00 0x01 0x00 0x00 0x02 0x00 0x00 0x00 0x00
|| [serial0.tx] 0x00 0x00 0x00 0x00 0x00 0x01 0x00 0x00 0x04 0x00 0x00 0x00 0x00 
\end{AnnotedLogFile}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{``UART is so slow!''}

\bfseries Scenario: \mdseries\par 
Some commands generate lots of UART output that the user does not care about while causing a slow down in the execution of commands

\bfseries Solution: \mdseries\par 
Mask sources/sinks appropriately to minimize generated spew without affecting routes. 

\subsubsection{Masking Sources}

If you know the particular source that is generating a lot of text output, you can mask off just that one:

\begin{CommandLine}
consolerouter --mask --src PmuCore
\end{CommandLine}

If you want to indiscriminately mask off all sources:

\begin{CommandLine}
consolerouter --mask --src *
\end{CommandLine}

If you're masking sources, it's usually recommended to mask off everything except errors and warnings. This way, you still get notified if 
something goes wrong:

\begin{CommandLine}
consolerouter --mask --src *.{print,debug,trace}
\end{CommandLine}

\begin{Note}
The above techniques only work if you don't have multiple sinks consuming text output (like \cmdline{serial} and \cmdline{smokey}). In that case, 
you don't want to mask off sources since no sink will get that text, including an entity like \cmdline{smokey}.
\end{Note}

\begin{Note}
Masking operations don't apply to the shell itself. If a command errors out, the shell will print the status code.
\end{Note}

\subsubsection{Masking Sinks}

You can use this technique to completely mask off a sink like \cmdline{serial} without affecting other sinks like \cmdline{smokey}. In this example, \cmdline{smokey} still gets 
all of its text traffic while the serial port gets none. This is extremely useful when running Smokey scripts without needing to inspect the output coming over UART:

\begin{AnnotedLogFile}
~\mp{Run Smokey}~ :-) smokey EdpTest --run
Smokey (local build commit ee9f8c9@) 2014/05/04 08:45:50

SrNm: DLXL100ZFMNM
MLB#: DLX326402CTFCCP1K
CFG#: J72-DVT/*/*/26251/MAIN-D-2-D-REL
ECID: 000003D44F169EE3

Control File:   nandfs:\AppleInternal\Diags\Logs\Smokey\EdpTest\J72\Main.plist
Script File:    nandfs:\AppleInternal\Diags\Logs\Smokey\EdpTest\J72\Main.lua
Log File:       nandfs:\AppleInternal\Diags\Logs\Smokey\EdpTest\Smokey.log
Results File:   nandfs:\AppleInternal\Diags\Logs\Smokey\EdpTest\PDCA.plist
Signature File: nandfs:\AppleInternal\Diags\Logs\Smokey\EdpTest\Earthbound.sig
Control Bit:    none

SequenceName:        EdpTest
SequenceVersion:     1
BehaviorOnFail:      KeepGoing
ResultsBehavior:     Bookend
LogBehavior:         Full
BrickRequired:       None
LogCollectorControl: None
ControlBitAccess:    Default

Sequence syntax and sanity check passed

Writing default results
Skipping control bit write
Writing PDCA plist file

Continuing without display
Continuing without charger
Device ready

Sequence execution...

Day/Time      Node
------------- ----
[27 02:40:29] N001 Repeating 1x
[27 02:40:29] .... 	[1] Periodic tasks
[27 02:40:29] N002 	[1] Repeating 1x
[27 02:40:29] .... 		[1] Action "BerRead"
[27 02:40:29] .... 			device -k Display@Internal -e ber read
------------------------------------------------------------------------------
:-) device -k Display@Internal -e ber read
ERROR: Did not find matching key: 'Display@Internal'
device returned Not Found error
------------------------------------------------------------------------------
[27 02:40:29] .... 			Exit code = 0x8000000E
[27 02:40:29] .... 			Shell command 1 failed
[27 02:40:29] .... 			ActionToExecute failed
[27 02:40:29] .... 		[1] Ignoring failure
[27 02:40:30] N001 Sequence done

Failed

Writing final results
Skipping control bit write
Writing PDCA plist file

All errors:
	SmokeyResults: failed action "BerRead" at node 2 iteration 1/1: 
    EfiCommand: command 1 had errors: device -k Display@Internal -e ber read

smokey returned Device Error error
~\mp{Mask Serial}~:-) consolerouter -m -d serial
Masking sink 'serial'
OK
~\mp{Re-run Smokey}~:-) smokey EdpTest --run --clean
device returned Not Found error
smokey returned Device Error error
\end{AnnotedLogFile}

\end{document}
