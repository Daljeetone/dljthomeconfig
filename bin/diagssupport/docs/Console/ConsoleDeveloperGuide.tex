%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Vim settings                                                             %%
%%    set noexpandtab                                                       %%
%%    set spell spelllang=en spellfile=SmokeyManual.en.utf-8.add            %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\include {ConsoleBase}
\begin{document}

%\addtolength{\parskip}{0.9mm}
\newgeometry{top=\TopMargin, bottom=\BottomMargin, hmargin=\TransverseMargin}
%\setlength{\parskip}{10pt}

\begin{titlepage}

\setlength{\parindent}{0in}

{
	\fontsize{32}{32}\selectfont
	\textcolor{AppleGray}{\AppleLogo}
}
\\[0.25in]

{
    \begin{spacing}{1.0}
	\fontsize{32}{32}\selectfont
	\textcolor{SmokeyDarkBlue}{\bfseries Console Framework} \\
	\textbf{Developer's Guide} \\
    \end{spacing}
}

June 11\textsuperscript{th} 2014
\\[0.25in]

Jerry Johns \\
System Software Engineering - Firmware \\
\small\texttt{jjohns@apple.com}

\vfill

\begin{center}
Apple Confidential --- DO NOT DISTRIBUTE
\end{center}

\end{titlepage}

\clearpage
\fancyhfoffset[r]{0in}
\pagenumbering{gobble}

\setcounter{tocdepth}{4}
\tableofcontents

\clearpage
\fancyhfoffset[l]{\BodyIndentLeft}
\fancyhfoffset[r]{0in}
% TODO: Why does using \restoregeometry instead of \newgeometry cause the
% following pages to shift downards?
%\restoregeometry
\newgeometry{top=\TopMargin, bottom=\BottomMargin, left=\LeftMargin, right=\TransverseMargin}
\pagenumbering{arabic}

\section{Introduction}

\subsection{What is this about?}

The console framework sits at the heart of EFI and manages all console traffic
that gets generated in the system. This framework was recently over-hauled and introduced 
a wealth of functionality that is beneficial to both developers and users alike. This document outlines the 
various new APIs that have been introduced and provides guidelines and best-practices for them. 

\subsection{Pre-requisites}

The core concepts introduced in the re-arch have been outlined in a companion document, the 
\cmdline{Console Framework User Guide}, namely \cmdline{Section 2: Framework Design}. It is assumed that the 
reader has read that before commencing this document.

\section{Module Registration}

This section dives into the registration API and how it should be used correctly for the various producers in EFI. 

\subsection{Legacy vs. Registered Sources}

By default, every macho/image in EFI registers a source against the console framework. This was put in place to faciliate 
the transition from the old world to the new. These producers are termed \cmdline{legacy sources} (happens implicitly 
as part of the call to \FuncRef{EfiInitializeDriverLib}). These sources do not export any debug masks or information about 
the source. In addition, the default name is set to the name of the image itself.

\cmdline{Registered sources} on the other hand explicitly call \FuncRef{EfiCoreLogRegisterModule} to register a source against the console framework. 
It can register optional debug masks as well as a name for reference.

\subsection{API}

\renewcommand{\arraystretch}{1.1}

\begin{CFunctionApi}{EfiCoreLogRegisterModule}{Registers a module with the console framework}
    ModuleLoggingInfo *ModuleInfo & Pointer to a structure that encapsulates information about the source (has to be static/global 
                           or heap memory that isn't freed after) \\
    ConsoleSourceRef *RefKey & Pointer to an opaque reference that will be updated to hold a unique key for that source \\ 
                           BOOLEAN SetAsDefaultModule & Sets this source as the default for the current image (See \NumNameRef{sec:API} below for usage examples) \\
    BOOLEAN IsLibrary & Used when registering from a library \\
\end{CFunctionApi}

\begin{CStructApi}{struct ModuleLoggingInfo}
    CHAR8 *ModuleName & Name of the Module \\
    DebugLogMaskInfo *MaskList & Pointer to a list of masks \\
    UINTN NumMasks & Number of masks in the list above \\
    UINT32 GlobalDebugLevels[1] & Global debug mask mapping (just one level) \\
\end{CStructApi}

\begin{CStructApi}{struct DebugLogMaskInfo}
DebugLogMask Mask & 32-bit mask value \\
CHAR8 *ModuleName & Module Name \\
UINTN NumMasks & Number of masks \\
\end{CStructApi}

\subsection{Usage}

The \StructRef{ModuleName} field should point to an ASCII name (in lower-case) that represents a chipset or functionality. \StructRef{GlobalDebugLevels[0]} should be set to a valid debug-mask as befitting the source. 

The \StructRef{RefKey}
passed in is an opaque reference that gets updated by the console framework. This key is to be later used with some of the logging functions (See \NumNameRef{sec:API}).

\subsection{Example}

\begin{SampleCode}
#define GG_DBGLVL_TYPE           (1 << 0)
#define GG_DBGLVL_PKTDATA        (1 << 1)
#define GG_DBGLVL_INFO           (1 << 2)

DebugLogMaskInfo gGgLogLevels[] = {
    {
        .Mask = GG_DBGLVL_INFO,
        .Name = "info",
        .Description = "Basic information on high level actions"
    },
    {
        .Mask = GG_DBGLVL_TYPE,
        .Name = "type",
        .Description = "Information on packet types + sizes"
    },
    {
        .Mask = GG_DBGLVL_PKTDATA,
        .Name = "pktdata",
        .Description = "Packet data"
    }
};

ModuleLoggingInfo gGgLoggingInfo = {
    .ModuleName = "gasgauge",
    .MaskList = gGgLogLevels,
    .NumLevels = count_of(gGgLogLevels),

    .GlobalDebugLevels = {
        GG_DBGLVL_INFO
    },
};

EFI_DRIVER_ENTRY_POINT(InstallGasGauge)

EFI_STATUS
InstallGasGauge (
		IN EFI_HANDLE		ImageHandle,
		IN EFI_SYSTEM_TABLE	*SystemTable
		)
{
	EFI_STATUS Status;
    ConsoleSourceRef *RefKey;

	EfiInitializeDriverLib(ImageHandle, SystemTable);
	EFI_DEVICE_PATH_PROTOCOL *Path = NULL;

    Status = EfiCoreLogRegisterModule(&gGgLoggingInfo, &RefKey, TRUE, FALSE);
    RETURN_EFI_ERROR(efiStatus);
}
\end{SampleCode}

In this example, the gas-gauge driver is registering a source (named \cmdline{gasgauge}) to be the default 
source for this driver. In the call to \FuncRef{EfiCoreLogRegisterModule}, it also signals that it is
not a library.

\subsection{Multiple Sources}

Some drivers (like \cmdline{PmuCore}) are multi-function drivers, i.e they install multiple protocols that respresent different 
functionalities (like \cmdline{Charger}, \cmdline{Adc} and \cmdline{PowerSource}). Drivers like these can register multiple 
sources - the only consideration is to ensure that the \StructRef{ConsoleSourceRef} keys passed back by the framework be stored so that they 
can be passed into the various logging functions:

\begin{SampleCode}
ModuleLoggingInfo gCharger = {
    .ModuleName = "charger",
    .LevelList = gChargerLevels,
    .NumLevels = count_of(gChargerLevels),

    .GlobalDebugLevels = {
        PMU_CHARGER_INFO
    },
};

ModuleLoggingInfo gAdc = {
    .ModuleName = "adc",
    .LevelList = gAdcLevels,
    .NumLevels = count_of(gAdcLevels),

    .GlobalDebugLevels = {
        PMU_ADC_INFO
    },
};

EFI_DRIVER_ENTRY_POINT(InstallGasGauge)

ConsoleSourceRef gAdcRef = NULL_CONSOLE_REF;
ConsoleSourceRef gChargerRef = NULL_CONSOLE_REF;

EFI_STATUS
InstallPmuCore (
		IN EFI_HANDLE		ImageHandle,
		IN EFI_SYSTEM_TABLE	*SystemTable
		)
{
	EFI_STATUS Status;

    Status = EfiCoreLogRegisterModule(&gCharger, &gChargerRef, FALSE, FALSE);
    RETURN_EFI_ERROR(efiStatus);

    Status = EfiCoreLogRegisterModule(&gAdc, &gAdcRef, FALSE, FALSE);
    RETURN_EFI_ERROR(efiStatus);
}
\end{SampleCode}

See section \NumNameRef{sec:API} for an example of using the provided \StructRef{ConsoleSourceRef} in a logging function. 

\subsection{Libraries}

When registering from a library, it's recommended that a method be exposed to allow the consumer to explicitly control registration of the logging source.

In addition, the \StructRef{ConsoleSourceRef} key should be made static to the file to prevent name collisions with other libraries. 

Finally, a value of \cmdline{TRUE} should be passed to the \FuncRef{IsLibrary} argument in the \FuncRef{EfiCoreLogRegisterModule} function.

\begin{SampleCode}
STATIC ModuleLoggingInfo gAudioLib = {
    .ModuleName = "audiolib",
    .LevelList = gAudioLibLevels,
    .NumLevels = count_of(gChargerLevels),

    .GlobalDebugLevels = {
        AUDIOLIB_INFO
    },
};

STATIC EntityRef gAudioLibRef = NULL;

EFI_STATUS 
AudioLib_RegisterLogging (
    )
{
    return EfiCoreLogRegisterModule(&gAudioLib, &gAudioLibRef, FALSE, TRUE);
}
\end{SampleCode}

\begin{Note}
Do not register libraries as the default source for the image, as all prints from that image will be tagged with the in-correct source.
\end{Note}

\subsection{Global Debug}
\label{sec:GlobalDebug}

Since global debug prints get logged into the forensics buffer, careful consideration has to be given to the the assignment of masks to the 
\StructRef{GlobalDebugLevels[0]} field to ensure no performance drop-offs when adding new prints (logging to forensics does take a small 
but finite amount of time).

In general, a source should only map high-level, informational prints that provide some level of visibility into driver operations to the 
global debug level. 

Intensive prints like dumping packet contents, or listing out explicit transaction details in a detailed manner \cmdline{*do not*} belong to the global 
debug level. It's generally recommended to register an `info' debug mask that encapsulates this high-level of debug verbosity.

\section{Logging}

This section goes over the new logging methods as well as providing guidelines for legacy methods. 

\subsection{Visibility}

Unlike previous methods like \FuncRef{LogStatus} or \FuncRef{PrintBlock} that required you to include additional libraries, the new logging methods 
are visibile from any-where in EFI (not PreEFI however). The only pre-requisite for usage is the inclusion of "EfiDriverLib.h" in your C source as well 
as linking against EfiDriverLib. Since almost all drivers and libraries already do this, it should amount to little work for most developers. 

\subsection{API}
\label{sec:API}

\bfseries Default Source:
\mdseries

All of the below methods get tagged with the default source for that image. For legacy sources, this means that the source name 
will be set to the image name. For registered sources, it will bind to the source that was registered as default. If sources 
were registered but none were set to default, the tagging will default to selecting the legacy source for that image (which is registered automatically in the call to \FuncRef{EfiInitializeDriverLib}). 

\medskip
\begin{tabu}[c]{| >{\footnotesize\ttfamily} p{2.0in} |  >{\small} p{3.85in} |}
    \taburulecolor{gray}
    \hline
    \rowfont{\normalfont\small\cellcolor{OutputBgColor}}
    \bfseries Method & \bfseries Description \\ \hline
    AsciiPrint(Format, ...) & Outputs 'print' type text \\
    LOG\_ERROR(Format, ...) & Outputs 'error' type text \\
    LOG\_WARN(Format, ...) & Outputs 'warn' type text \\
    LOG\_DEBUG(Mask, Format, ...) & Outputs 'debug' type text given a debug mask\\
    LOG\_DUMP(Mask, Buffer, Len) & Dumps out the contents of a buffer in hex over the 'debug' text type\\
    LOG\_TRACE\_FUNCENTRY() & Marks entry into a function, of 'trace' type \\
    LOG\_TRACE\_FUNCEXIT() & Marks exit out of a function, of 'trace' type \\
    LOG\_TRACE\_MARKER(Format, ...) & Custom marker break-crumbs, outputs 'trace' type \\
    \hline
\end{tabu}
\medskip

\begin{Note}
A call to \FuncRef{LOG\_DEBUG} only works if a default source that has debug-masks has been registered by the image from which 
that call is being made. 
\end{Note}

\bigskip
\bfseries Specific Source:
\mdseries

To tag a print as emnating from something other than the default source, just call the above functions with an 'M' pre-pended to the
function name (e.g \FuncRef{MLOG\_ERROR}, \FuncRef{MAsciiPrint} or \FuncRef{MLOG\_DEBUG}).

All of the 'M' series functions require the user pass in the \StructRef{ConsoleSourceRef} key as an additional first argument - this is 
especially pertinent for multi-function drivers and libraries:

\begin{Struct}
MLOG_ERROR(Ref, Format, ...)
MLOG_DEBUG(Ref, Mask, Format, ...)
\end{Struct}

Sample code:

\begin{SampleCode}
#define AUDIOLIB_INFO    (1 << 0)

static ConsoleSourceRef gAudioLibRef = NULL_CONSOLE_REF;

void
SomeFunction() (
    )
{
    MAsciiPrint(gAudioLefRef, "Test print!\n");
    MLOG_DEBUG(gAudioLibRef, AUDIOLIB_INFO, "Test info debug print!\n");
}

static ModuleLoggingInfo gAudioLib = {
    .ModuleName = "audiolib",
    .MaskList = gAudioLibLevels,
    .NumMasks = count_of(gChargerLevels),

    .GlobalDebugLevels = {
        AUDIOLIB_INFO
    },
};

EFI_STATUS 
AudioLib_RegisterLogging (
    )
{
    return EfiCoreLogRegisterModule(&gAudioLib, &gAudioLibRef, FALSE, TRUE);
}
\end{SampleCode}

\subsection{Legacy Functionality}

All legacy functions (like \FuncRef{DEBUG} and \FuncRef{LogDebug}) have been ported over to the new architecture. 
However, it is \bfseries *not recommended* \mdseries to use these functions anymore on a continuing basis. All new drivers should register
sources and utilize the new API for their logging needs. 

\subsubsection{DEBUG() and LogDebug()}

Since both \FuncRef{LOG\_DEBUG} and \FuncRef{MLOG\_DEBUG} calls require the caller to pass in a debug-mask associated with the default/specific 
module respectively, there was no easy way to map over the \FuncRef{DEBUG} and \FuncRef{LogDebug} calls. 

Hence, a new \cmdline{system} source was created to house the \FuncRef{DEBUG} print family as well as \FuncRef{LogDebug}. This source is available 
system-wide and can be seen by any entity that has access to gRT. 

All of the \StructRef{EFI\_D\_*} defines have been mapped under the system source:

\begin{SampleCode}
DebugLogMaskInfo gSystemLevelList[] = {
    {
        .Mask = EFI_D_INIT,
        .Name = "init",
        .Description = "Initialization prints"
    },
    {
        .Mask = EFI_D_WARN,
        .Name = "warn",
        .Description = "Warnings"
    },
    {
        .Mask = EFI_D_LOAD,
        .Name = "load",
        .Description = "Driver load"
    },
    {
        .Mask = EFI_D_ERROR,
        .Name = "error",
        .Description = "Error/info",
    },
    {
        .Mask = EFI_D_DEBUG,
        .Name = "debug",
        .Description = "LogDebug() prints"
    },        
    ...
    ...
};

ModuleLoggingInfo gSystemLoggingInfo = {
    .ModuleName = "system",
    .MaskList = gSystemMaskList,
    .NumMasks = count_of(gSystemMaskList),
    .GlobalDebugLevels = {
        EFI_D_ERROR,
    }
};

\end{SampleCode}

A new \StructRef{EFI\_D\_DEBUG} define has been added under the \cmdline{system} source, and \FuncRef{LogDebug} has been mapped to that. 

\subsubsection{Other functions}
\FuncRef{LogStatus} has been mapped to \FuncRef{AsciiPrint}, while \FuncRef{LogError} has been mapped to \FuncRef{LOG\_ERROR}.

\section{Summary}

\subsection{Guidelines}

\begin{enumerate}
\item When writing a new driver, please refrain from using any of the legacy methods. Rather, create a new source as well as appropriate debug flags 
and use those instead. 
\item For debug spew, do not use \FuncRef{DEBUG} or \FuncRef{LogDebug} going forward (both new and old drivers). Rather, use the new \FuncRef{LOG\_DEBUG}
macro instead with custom debug masks
\item Be very mindful of the masks you assign to the \StructRef{GlobalDebugMask} field since they get logged to forensics and can affect performance 
    (See~\NumNameRef{sec:GlobalDebug}).
\end{enumerate}

\subsection{Sample Drivers}

There are a few sample drivers that showcase correct usage of the new framework methods. These are:

Drivers:
\begin{enumerate}
    \item \bfseries Gas Gauge - \mdseries bootloader/Platform/TI/Common/Chipset/BQ27541
    \item \bfseries UART Swif - \mdseries bootloader/Platform/Samsung/Common/Chipset/S5L8940/UartSwif 
    \item \bfseries Serial - \mdseries bootloader/Platform/Samsung/Common/Chipset/Common/Uart 
\end{enumerate}

\medskip

Libraries:
\begin{enumerate}
    \item \bfseries I2clib (for libraries) - \mdseries bootloader/Platform/Apple/Common/Library/I2CLib
    \item \bfseries Ezlink (for libraries) - \mdseries bootloader/Platform/Apple/Common/Library/EzLink
\end{enumerate}

\end{document}
