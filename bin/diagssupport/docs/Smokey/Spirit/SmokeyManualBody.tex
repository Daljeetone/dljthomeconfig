%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% vim: set noexpandtab tw=0 indentexpr=:                                   %%
%% vim: set spelllang=en:                                                   %%
%%      set spellfile=SmokeyManual.en.utf-8.add                             %%
%%      set spell                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%                DO NOT CONVERT TABS TO SPACES IN THIS FILE                %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO:
%%   - Change "Command Line Arguments" to "Command Line Options"?
%%   - Create a cross-reference table for "Setting Up the Host and DUT"
%%   - Change textual references to \NameRef or \NumNameRef
%%       - above, below, following, preceeding
%%   - Explain \param{Sequence} and \param{Platform} in \func{require}
%%     description (that notation is mainly used in the command line
%%     descriptions)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}

\subsection{What is Smokey?}

Smokey is a scripting and sequencing environment within EFI diagnostics on
mobile platforms, including iPhones, iPads, iPods, and AppleTV.  Its goals are
to enable automated low-level testing and data collection across factory and
engineering scenarios.

\subsection{Audience}

This document is intended for the engineers involved with the development and
use of the EFI diagnostic environment.

On the producer side, this manual addresses EFI diagnostic firmware engineers,
the people who will maintain and enhance Smokey.

On the consumer side, this manual addresses factory and non-factory users.
Factory users include station DRIs.  Non-factory users include hardware
engineers needing a platform for validation or stress testing.

\subsection{Document Objective}

This document is generally intended to be an all-around reference, but written
with the intent of bringing Smokey's core users up to speed about the
environment.  

On the producer side, this manual intends to educate software engineers about
the functionality and intent of the system.  The goal is to exposit the design
and shed light on the considerations required to either maintain or enhance the
software.

On the consumer side, this manual presents the features available in the Smokey
environment.  Additionally, time will be spent to document requirements,
prerequisites, and expected behaviors.  The goal is to arm users with the
knowledge to bootstrap their own test sequences.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Lua Fundamentals}

\subsection{Lua}

The Lua language is a product of the Tecgraf group at PUC-Rio (Pontifical
Catholic University of Rio de Janeiro) and is intended to be a powerful, fast,
lightweight, embeddable scripting language.  It has dynamic data types,
built-in support for associative arrays, and offers automatic memory
management.  Scripts are internally translated into byte code that is executed
by an internal virtual machine.

The name ``Lua'' is Portuguese for ``moon''.  Scripts in the Lua language have
the extension \filename{.lua} and the files are encoded in ASCII.

Lua is the adopted language of the Smokey environment.  On top of the benefits
listed above, Lua was chosen because both the interpreter and its built-in
libraries are easy to port to the EFI environment without compromising their
feature sets.  Additionally, the language, code base, and community support are
both mature and stable.

All interactions between users (i.e., scripts) and the platform (e.g., lower
software stack, hardware drivers) will be in the form of Lua function calls,
either direct or via tables, and Lua  data types.  Smokey provides custom APIs
to make these interactions easier to manage.

Since it is not the intent of this document to teach Lua (see References
section), the following is only meant to help kick-start seasoned programmers.

\subsection{Data}

\subsubsection{Built-in Types}

Lua provides six built-in types that will be fundamental to writing test
scripts.  They are summarized in table \ref{tab:LuaTypes}.

\begin{lrbox}{\RightBoxA}
\begin{NestedLuaCode}[linewidth=1.25in]
nil
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxB}
\begin{NestedLuaCode}[linewidth=1.25in]
true
false
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxC}
\begin{NestedLuaCode}[linewidth=1.25in]
"foo"
'bar'
[[baz]]
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxD}
\begin{NestedLuaCode}[linewidth=1.25in]
123   -- Dec
0x123 -- Hex
10.5  -- Real
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxE}
\begin{NestedLuaCode}[linewidth=1.25in]
{ 1, 2, 3 }
{ a=1, b=2 }
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxF}
\begin{NestedLuaCode}[linewidth=1.25in]
function foo ()
	return 123
end
\end{NestedLuaCode}
\end{lrbox}

\begin{table}

	\begin{LuaTypeTable}

		Nil & Value & Represents the lack of a value.  Can be used as a
		placeholder. There is only one value. &
		\UseLuaCodeBox{\RightBoxA} \\

		Boolean & Value & Bimodal logical state.  There are only two
		values.  & \UseLuaCodeBox{\RightBoxB} \\

		String & Reference & Doubly-, singly-, and bracket-quoted text.
		The string can contain any character and there is no
		terminating sentinel value. & \UseLuaCodeBox{\RightBoxC} \\

		Number & Value & Integers in base 10 and 16.  Floating point
		numbers in base 10 only. & \UseLuaCodeBox{\RightBoxD} \\

		Table & Reference & Associative map from keys to values.
		Tables store keys and values of any type or value except
		\keyword{nil}. & \UseLuaCodeBox{\RightBoxE} \\

		Function & Reference & Chunk of executable code.  Anonymous
		functions are supported. & \UseLuaCodeBox{\RightBoxF} \\
		
	\end{LuaTypeTable}

	\caption{Lua Types}
	\label{tab:LuaTypes}

\end{table}

All data types are first class citizens in Lua: they can be used in
expressions, assigned to variables, passed as function arguments, and be
returned from functions.  This is notably true for functions, which may be a
novel idea to programmers familiar with languages like C because it means that
functions can be a unit of execution, an input, or an output.

\subsubsection{Dynamic Typing}

Lua variables are dynamically typed.  That is, they do not have a predetermined
type and will become the type of the value being assigned.  Lua will make an
attempt to ``do the right thing'' and cast between strings, booleans, and
numbers when mismatched types are used together.

While there are no mechanisms to restrict types, there is a built-in
\func{type} function to inspect types.

\subsubsection{Scope}

Variables in Lua are defined the moment they are assigned a non-\keyword{nil}
value.  They exist until the end of the code chunk in which they were defined,
or until garbage collection, whichever occurs later.

Between nested code chunks, it is important to remember that Lua variables are
lexically scoped.  In the case that the same variable name is used amongst
different nesting levels, the nested chunks can ensure that they are using
their own variable by applying the \keyword{local} keyword during variable
declaration.

\subsubsection{Binding}
\label{sec:DynamicBinding}

Dynamic binding means that variable names can refer to something different each
time they are used.  In Lua, this means that a simple assignment operation can
be used to change both the type and value of a variable.  C programmers, in
particular, should note that this applies to functions, so it is possible to
rename functions or replace the underlying implementation on the fly.

Lua's binding behavior is aided by the way that Lua treats certain types as
references.  In the Lua virtual machine, reference variables are pointers to
individual blocks of memory, each holding a single value, be it a string,
table, or function.  Conversely, reference values in Lua have no dedicated
names and, in fact, a single value in memory can have multiple names.  Each
block of memory has a type, but variables can generally reference any block.

Binding is related to scoping in that scope affects the range of values that
can be assigned to a variable at any given time.  Additionally, a variable's
scope affects which functions can modify its value and, in turn, affects its
ultimate value at time of use.  This is especially true if its scope is not
locked down with judicious use of the \keyword{local} keyword.  Developers will
need to keep this in mind when investigating unexpected run-time behavior that
involve overwritten variables or function references.

\subsubsection{Mutation}
\label{sec:DataMutation}

Most values in Lua are immutable.  This means that a value's contents typically
do not change.  For example, new strings and functions can be created and
thrown away, but Lua does not provide a means to modify the characters in the
string nor the commands in the function.

The lone exception is the table type.  All references to a table are affected
when one reference is used to add, replace, or delete key-value pairs.  This
can be useful, in practice, as a means to communicate data between functions,
but is also a liability in terms of data integrity.  Tables should be deeply
copied if they must be shared without affecting the original.

\subsubsection{Nil Values}

In Lua, any variable that is not defined will automatically receive the value
\keyword{nil}.  Conversely, any variable assigned the value \keyword{nil} is
effectively deleted from the virtual machine.

Developers must be diligent in checking for mistyped names.  A typo or wrong
letter case will not be flagged by the Lua interpreter, which can lead to very
confusing run-time behavior.  A text editor that supports autocomplete or
sophisticated highlighting is highly recommended.

\subsubsection{Multiple Values}

Lua supports assigning and returning multiple values at a time through use of
the comma operator.  Any missing value in a tuple is automatically assigned the
value \keyword{nil}.

\begin{LuaCode}
a, b = 1, 2   -- a = 1 and b = 2
c, d = nil, 3 -- c = nil and d = 3
e, f = 4      -- e = 4 and f = nil
\end{LuaCode}

\begin{LuaCode}
function foo ()
	-- Return two values
	return 1, 2
end
\end{LuaCode}

\subsection{Comments}

Lua comments are akin to C++ comments.

\subsubsection{Single-line Comments}

Basic comments start with a double dash and run until the end of the line.

\begin{LuaCode}
-- This line is not code
\end{LuaCode}

\begin{LuaCode}
x = 3 -- Assign 3 to the variable 'x'
\end{LuaCode}

\subsubsection{Delimited Comments}

Longer comments are delimited by a double dash and double bracket pair.

\begin{LuaCode}
--[[
This line is not code
Nor is this line
--]]
\end{LuaCode}

\begin{LuaCode}
y = --[[ These words are not code --]] 5
\end{LuaCode}

\subsection{Boolean Expressions}

\subsubsection{Relational Operators}

Lua has all the basic relational operators.

\begin{LuaCode}
a > b  -- Greater than
a < b  -- Less than
a >= b -- Greater/Equal
a >= b -- Less/Equal
a == b -- Equal
a ~= b -- Not equal
\end{LuaCode}

\subsubsection{Logical Operators}

Logical operators are spelled out.

\begin{LuaCode}
(a < b) or (c < d)  -- Disjunction
(a < b) and (b < c) -- Conjunction
not (a < b)         -- Negation
\end{LuaCode}

\subsubsection{Conditionals}

Any value that is neither \keyword{nil} nor \keyword{false} is considered to be
a boolean true.  This means that numbers, strings, functions, and tables are
considered true.  Counterintuitively to C/C++ programmers, this also means that
the number 0 is considered true.

\begin{LuaCode}
nil             -- False
false           -- False
true            -- True
0               -- True
1.5             -- True
"foo"           -- True
{ a = 5 }       -- True
function () end -- True
\end{LuaCode}

\subsubsection{Checking Existence}

As a best practice, any code checking whether a variable is set should
explicitly compare against \keyword{nil} rather than using the variable itself
as the expression.

\begin{lrbox}{\LeftBoxA}
\begin{NestedLuaCode}[linewidth=2.5in]
-- Bad practice check for existence
if (x) then
	foo()
end
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxA}
\begin{NestedLuaCode}[linewidth=2.5in]
-- Good practice check for existence
if (x ~= nil) then
	foo()
end
\end{NestedLuaCode}
\end{lrbox}

\begin{SideBySideGrid}

	\UseLuaCodeBox{\LeftBoxA} \NextColumn \UseLuaCodeBox{\RightBoxA}

\LastRow
\end{SideBySideGrid}

\subsection{Tables}

Lua tables are associative hashes and are used through the language for both
storage and also for program organization.

\subsubsection{Storage}

Defining tables with implicit (i.e., numeric) keys.

\begin{LuaCode}
t = { 10, 20, 30 }
u = { "a", "b", "c" }
v = { 10, "z", false }
\end{LuaCode}

Defining tables with explicit key-value pairs.

\begin{LuaCode}
w = { [1]=10, [10]=20, [100]=30 }
x = { a=1, b=2, c=3 }
\end{LuaCode}

Arbitrary strings as keys.

\begin{LuaCode}
x2 = { ["a"]=1, ["b"]=2, ["c"]=3 } -- Equivalent to x
y = { ["key A"]=1, ["key B"]=2, ["key C"]=3 }
\end{LuaCode}

Arbitrary values as keys.

\begin{LuaCode}
foo = "foo"
bar = function () return "bar" end
baz = { "baz" }
z = { [foo]=1, [bar]=2, [baz]=3 }
\end{LuaCode}

\subsubsection{Access}

Typical table access use familiar bracket notation.

\begin{LuaCode}
a = t[1]
b = t[a]
\end{LuaCode}

Keys that are strings have special syntactic sugar.

\begin{LuaCode}
-- These two assignments are the same
b = z["a"]
c = z.a
\end{LuaCode}

Walking through a generic table can be done with a \keyword{for} loop and the
\func{pairs} iterator.  Note that traversal order is not guaranteed for tables
that use non-numeric keys.

\subsubsection{Arrays}

Lua does not have a built-in array type.  Rather, it depends on tables whose
keys are contiguously numbered integers.  All Lua arrays start at index 1.

\begin{LuaCode}
t = { 10, 20, 30 }
foo(t[1]) -- The argument value is 10
foo(t[2]) -- The argument value is 20
foo(t[3]) -- The argument value is 30
\end{LuaCode}

Walking through an array can be done with a \keyword{for} loop and the
\func{ipairs} iterator.  Note that traversal starts with index 1 and ends when
the next consecutive index is undefined or was assigned the value
\keyword{nil}.

\subsubsection{Classes}

Lua doesn't have a class system per se, but it is possible to emulate their
behavior using tables with keys that are strings and values that are functions.

Lua provides some syntactic sugar to make class methods easy to declare.

\begin{lrbox}{\LeftBoxA}
\begin{NestedLuaCode}[linewidth=2.5in]
-- Declare method f() inside table t
-- the hard way
t = {
	m = 1,
	f = function (self, a, b)
		return self.m * a + b
	end
}
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\LeftBoxB}
\begin{NestedLuaCode}[linewidth=2.5in]
-- Call f() the hard way
x = t.f(t, 1, 2)
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxA}
\begin{NestedLuaCode}[linewidth=2.5in]
-- Declare method f() inside table t
-- the easy way
t = {
	m = 1
}
function t:f (a, b)
	return self.m * a + b
end
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxB}
\begin{NestedLuaCode}[linewidth=2.5in]
-- Call f() the easy way
x = t:f(1, 2)
\end{NestedLuaCode}
\end{lrbox}

\begin{SideBySideGrid}

	\UseLuaCodeBox{\LeftBoxA} \NextColumn \UseLuaCodeBox{\RightBoxA}

\LastRow
\end{SideBySideGrid}

Calling a class method and passing in the ``self'' pointer has syntactic
sugar, too.

\begin{SideBySideGrid}

	\UseLuaCodeBox{\LeftBoxB} \NextColumn \UseLuaCodeBox{\RightBoxB}

\LastRow
\end{SideBySideGrid}

The syntax \keyword{t:f()} implicitly passes \keyword{t} as the first argument
to \keyword{f}.  Note that it is possible and easy to mistakenly call
\keyword{f} using the normal table access syntax of \keyword{t.f()} without any
complaint from Lua.   However, your code may misbehave because it will not have
the correct arguments!

When two or more instances of the same class are required, a constructor method
will be required to generate a new Lua table and copy the members and methods.
This won't be covered in detail here, but the references in section
\ref{sec:LuaLinks} may prove helpful.

\subsection{Language Constructs}

The Lua syntax will look familiar to any programmers of ALGOL-influenced
languages like C/C++, Pascal, Python, or Perl.   

\subsubsection{Conditionals: if-then-else}

\begin{LuaCode}
if (a > 0) then
	x = 1
end
\end{LuaCode}

\begin{LuaCode}
if (a > 0) then
	x = 1
else
	x = 0
end
\end{LuaCode}

\begin{LuaCode}
if (a > 10) then
	x = 2
elseif (a > 0) then
	x = 1
else
	x = 0
end
\end{LuaCode}

\subsubsection{Loops: for-do}

\begin{LuaCode}
-- Iterate from 1 to 10
for x = 1, 10 do
	foo(x)
end
\end{LuaCode}

\begin{LuaCode}
-- Iterate on every third number from 1 to 10
for x = 1, 10, 3 do
	foo(x)
end
\end{LuaCode}

\begin{LuaCode}
-- Iterate on all table entries
for key, value in pairs(t) do
	t[key] = value + 1
end
\end{LuaCode}

\begin{LuaCode}
-- Iterate on all array entries
for i, value in ipairs(t) do
	t[i] = value + 1
end
\end{LuaCode}

\subsubsection{Loops: while-do}

\begin{LuaCode}
-- Compute powers of 2 less than 1000
-- until foo()
x = 1
while (x < 1000) do
	x = x * 2
	if (foo(x)) then
		break
	end
end
\end{LuaCode}

\subsubsection{Loops: repeat-until}

\begin{LuaCode}
-- Add bar() while less than 1000 and
-- not foo()
x = 0
repeat
	x = x + bar()
	if (foo(x)) then
		break
	end
until (x > 1000)
\end{LuaCode}

\subsubsection{Functions}

\begin{LuaCode}
-- Normal function definition
function foo (x, y, z)
	return x + y + z
end
a = foo(1, 2, 3)
\end{LuaCode}

\begin{LuaCode}
-- Anonymous function in a variable
bar = function (x, y, z)
	return x + y + z
end
b = bar(1, 2, 3)
\end{LuaCode}

\begin{LuaCode}
-- Variadic/Vararg fuction
function baz (p, f, ...)
	local h = io.open(p, "a")
	h:write(string.format(f .. "\n", ...))
	h:close()
end
baz("log.txt", "Temperature is %dC", 100)
\end{LuaCode}

\begin{LuaCode}
-- Functions are first-class citizens
function map (f, t)
	local c = {}
	local n
	for i, v in ipairs(t) do
		n = f(v, c)
	end
	return n
end
function qux (s)
	return function (v, c)
		c.str = (c.str or s) .. v
		return c.str
	end
end
word = map(qux("hand"), { "crafts", "man", "ship" })
\end{LuaCode}
%word = map(qux("counter"), { "clock", "wise" })

\subsection{Built-in Facilities}

\subsubsection{String Concatenation}

Strings are joined with the double-dot operator.

\begin{LuaCode}
x = "to" .. "get" .. "her"
\end{LuaCode}

\subsubsection{\func{string.format} Function}

Lua supports a limited subset of the \func{printf} semantics from C.

\begin{LuaCode}
x = 100
s = string.format("%dKHz", x)
\end{LuaCode}

\subsubsection{Bitwise Operations}

Bit manipulation is available in the form of library calls rather than being
syntactically  integrated into the language like in C.  Operations are limited
to 32-bit quantities.

\begin{LuaCode}
-- Assume: uint32_t x, a, b, n
--         int32_t k
x = bit32.band(a, b)    -- x = a & b
x = bit32.bor(a, b)     -- x = a | b
x = bit32.bxor(a, b)    -- x = a ^ b
x = bit32.bnot(a)       -- x = ~a
x = bit32.lshift(a, n)  -- x = a << n
x = bit32.rshift(a, n)  -- x = a >> n
x = bit32.arshift(k, n) -- x = k >> n
x = bit32.lrotate(a, n) -- x = (a<<n) & (a>>(32-n))
x = bit32.rrotate(a, n) -- x = (a>>n) & (a<<(32-n))
if (bit32.btest(a, b))  -- if (a & b)
\end{LuaCode}

More complicated extractions and injections of fields are available as well.

\begin{LuaCode}
-- m = ((1 << w) - 1)
-- x = (a >> n) & m
x = bit32.extract(a, n, w)
\end{LuaCode}

\begin{LuaCode}
-- m = ((1 << w) - 1)
-- x = (a & ~(m << n)) | ((b & m) << n)
x = bit32.replace(a, b, n, w)
\end{LuaCode}

\subsubsection{\func{tonumber} Function}

Lua will try to convert values to numbers implicitly in some scenarios, but it
is often useful to do this manually.

\begin{LuaCode}
x = tonumber("100")
\end{LuaCode}

\subsubsection{\func{tostring} Function}

Lua will try to convert values to strings implicitly, but it is sometimes
useful to do this manually.

\begin{LuaCode}
x = 100
s = tostring(x) .. "KHz"
\end{LuaCode}

\subsubsection{\func{type} Function}

The type of a variable can be inspected using the \func{type} function.  It
returns a string describing the type.

\begin{LuaCode}
if (type(x) == "nil") then
	foo(1)
elseif (type(x) == "boolean") then
	foo(2)
elseif (type(x) == "string") then
	foo(3)
elseif (type(x) == "number") then
	foo(4)
elseif (type(x) == "function") then
	foo(5)
elseif (type(x) == "table") then
	foo(6)
else
	foo(7)
end
\end{LuaCode}

\subsection{Exceptions}
\label{sec:LuaExceptions}

\subsubsection{Raising Exceptions}

The current context of execution can be aborted by raising an exception.
Arbitrary data can be sent up as part of the exception; descriptive strings are
helpful if an outer code layer can expect and print them.

\begin{LuaCode}
function f (x)
	if (x > 100) then
		error("Too large")
	end
end
\end{LuaCode}

\begin{LuaCode}
function g (x)
	if (x < 0) then
		error({ "Too small", x })
	end
end
\end{LuaCode}

\subsubsection{Catching Exceptions}

Exceptions can be caught by using Lua's \func{pcall} function to make a
protected function call.  Note that the parameters to \func{pcall} need to be a
function value (either a function name or an anonymous function declaration)
followed by that function's arguments, not a function call.  On success,
\func{pcall} returns \keyword{true} and all the values returned by the suspect
function.  On failure, \func{pcall} returns \keyword{false} and the exception
data, if any.

\begin{LuaCode}
-- Safely call a function with two arguments and
-- expect two return values
p, v, w = pcall(foo, 10, 20)
if (p) then
	print("foo(10, 20) = " .. v .. ", " .. w)
else
	print("caught: " .. tostring(v))
end
\end{LuaCode}

\begin{LuaCode}
-- Use anonymous function to sugar-coat a method call
-- (Also take advantage of Lua tail calls)
p, v = pcall(function () return t:f(1, 2, 3) end)
if (p) then
	print("t:f(1, 2, 3) = " .. v)
else
	print("caught: " .. tostring(v))
end
\end{LuaCode}

\begin{LuaCode}
-- Simple exception catcher/printer
function guard (f, ...)
	local t = table.pack(pcall(f, ...))
	local p, v = t[1], t[2]
	if (p) then
		return table.unpack(t, 2, t.n)
	else
		print("caught: " .. tostring(v))
	end
end
-- Safely execute bar(20)
guard(bar, 20)
\end{LuaCode}

Since exceptions may be of any data type, code that uses \func{pcall} should
not expect the exception value to behave in any particular way.  If the
exception must be printed or manipulated, Lua's built-in \func{tostring} and
\func{tonumber} functions should be used to coerce the value to a known type.

\subsection{Tricks}

\subsubsection{Data Alternation and Short Circuit Evaluation with Boolean Expressions}

Lua's logical \keyword{and} and logical \keyword{or} operators do not return
their results as a boolean type.  Instead, they return the operand whose value
satisfies the operator first.

\begin{lrbox}{\LeftBoxA}
\begin{NestedLuaCode}[linewidth=2.5in]
x = true and 1   -- Value is 1
y = nil and true -- Value is nil
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxA}
\begin{NestedLuaCode}[linewidth=2.5in]
a = 3 or true    -- Value is 3
b = nil or "foo" -- Value is "foo"
\end{NestedLuaCode}
\end{lrbox}

\begin{SideBySideGrid}

	\UseLuaCodeBox{\LeftBoxA} \NextColumn \UseLuaCodeBox{\RightBoxA}

\LastRow
\end{SideBySideGrid}

Note that short circuit evaluation is a consequence of the way boolean
operators are defined in Lua.

\begin{lrbox}{\LeftBoxB}
\begin{NestedLuaCode}[linewidth=2.5in]
x = true and foo() -- Calls foo()
y = nil and foo()  -- Won't call foo()
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxB}
\begin{NestedLuaCode}[linewidth=2.5in]
a = 3 or bar()   -- Won't call bar()
b = nil or bar() -- Calls bar()
\end{NestedLuaCode}
\end{lrbox}

\begin{SideBySideGrid}

	\UseLuaCodeBox{\LeftBoxB} \NextColumn \UseLuaCodeBox{\RightBoxB}

\LastRow
\end{SideBySideGrid}

In the case of functions that take optional arguments, booleans make it easy to
provide a default value if none is specified.

\begin{LuaCode}
function f (x)
	-- If x is specified, return x + 1
	-- If not, return 100
	return (x or 99) + 1
end
\end{LuaCode}

\subsubsection{Ternary-Like Operator}

Lua does not support the question mark operator in C and C++.  However, the
in-line ``if-then-else'' semantics are partially supported by Lua boolean
expressions.

\begin{LuaCode}
-- Similar to:
--	if (a) then
--		x = b
--	else
--		x = c
--	end
x = a and b or c
\end{LuaCode}

The caveat is that the ``then'' part of the expression must not be false
because that situation will cause Lua to use the ``else'' portion.

\begin{LuaCode}
-- WARNING!  Both are same as x = c
x = a and nil or c
x = a and false or c
\end{LuaCode}

The workaround is to ensure that the ``then'' portion is always true.  This can
be done by negating the conditional and swapping the ``then'' and ``else''
portions.  If neither portion can be guaranteed to be true, the full
``if-then-else'' construct must be used instead.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Smokey Fundamentals}
\label{sec:Fundamentals}

\subsection{Sequences: Scripts and Property Lists}

Smokey is an scripting and sequencing environment that provides an automated
means by which to execute structured code in a configurable order.  Its main
inputs are two specifically named files---a \jargon{script file} and a
\jargon{property list file}---in a user-defined directory.  Together, the files
form a \jargon{sequence}.  The sequence takes its name from the directory name.

The script file shall have an extension of \filename{.lua} to indicate that it
is a Lua script file.  Its contents shall be any content that would be
accepted by a standard, standalone Lua interpreter.  This file will define Lua
functions that Smokey will execute as \jargon{actions} in the order defined by
the property list file.

The property list file shall have an extension of \filename{.plist} and be
encoded as an Apple property list in ASCII format.  This file will define the
parameters of the sequence, including the order of actions defined in the
script file, prerequisite and co-requisite conditions, as well as run-time
Smokey behavior.

\subsection{File Organization}
\label{sec:FileOrg}

\subsubsection{Home Folder}

Smokey has a fixed home.  Input and ancillary files are stored under the home
folder.

\begin{Setting}
nandfs:\AppleInternal\Diags\Logs\Smokey
\end{Setting}

\subsubsection{Sequence Name and Location}

Smokey sequences are stored as directories on the DUT under the Smokey folder. 

\begin{Setting}
nandfs:\AppleInternal\Diags\Logs\Smokey\~\param{Sequence}~
\end{Setting}

Sequences are named after the folder containing its files.  For example, a
sequence named ``Wildfire'' would be in a folder named \dirname{Wildfire} under
the Smokey folder.

\subsubsection{Sequence Folder Layout}
\label{sec:FolderLayout}

Within the sequence directory will be a number of files.  Some will be
generally required by Smokey, some may be tied to the platform, and others may
be specific to the sequence implementation.  For illustration, figure
\ref{fig:FolderLayout} shows the different ways that Smokey sequences can be
laid out.  The following sections will discuss the contents of sequences and
how the layouts are used.

\begin{figure}[h]

	\begin{SideBySideBySideGrid}

		\HeadingRow{Generic}{Platform Only}{Fall-Back}

	\NextRow

		% Generic
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\File{.FactoryLogs...}
			\File{Earthbound.sig}
			\File{Main.lua}
			\File{Main.plist}
			\File{PDCA.plist}
			\File{Smokey.log}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		% Platform Only
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\Directory{\param{platform}}{
				\File{Main.lua}
				\File{Main.plist}
			}
			\File{.FactoryLogs...}
			\File{Earthbound.sig}
			\File{PDCA.plist}
			\File{Smokey.log}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		% Fall-Back
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\Directory{\param{platform}}{
				\File{Main.lua}
				\File{Main.plist}
			}
			\File{.FactoryLogs...}
			\File{Earthbound.sig}
			\File{Main.lua}
			\File{Main.plist}
			\File{PDCA.plist}
			\File{Smokey.log}
		}
		\end{NestedDirectoryTree}

	\LastRow
	\end{SideBySideBySideGrid}

	\caption{Supported Sequence Folder Layouts}
	\label{fig:FolderLayout}

\end{figure}

\paragraph{Sequence Contents}

Sequence developers are expected to match one of Smokey's supported folder
layouts.  However, not all files will be required under all scenarios.  The
following two files are required.  The names are fixed, but the location can
vary in order to facilitate platform specialization.  Both files must be in the
same directory.

\begin{Definition}

	\item[Main.lua] This is the script file for the sequence.

	\item[Main.plist] This is the property list file for the sequence.

\end{Definition}

The following files are output files that must be preallocated on the
filesystem by the user.  Refer to section \NumNameRef{sec:FileOutput} for
details on how the output files are used, how to work with them, and when they
are required.

\begin{Definition}

	\item[PDCA.plist] Stores sequence results, including attributes, data,
	and test outcome.\footnote{See section
	\NumNameRef{sec:LogCollectorFiles}.\label{fn:LogCollectorFiles}}

	\item[Smokey.log] Stores the running sequence log.\footnote{See section
	\NumNameRef{sec:SeqOut}.}

	\item[.FactoryLogsWaitingToBeCollected] Specific to
	LogCollector.\footref{fn:LogCollectorFiles}  This file is special and
	should be acquired from the EFI Diagnostics team.

	\item[Earthbound.sig] Specific to Earthbound.\footnote{See section
	\NumNameRef{sec:EarthboundFiles}.}

\end{Definition}

Additional user files and directories for code and auxiliary data may exist
anywhere within the sequence folder and below.  Smokey supports the
\func{FindSequenceFile} and \func{require} functions\footnote{See section
\NumNameRef{sec:SmokeyApi}.\label{fn:LocatorFunctions}} to aid in locating
these files at run time.

\paragraph{Sequence Platform Specialization}

Test sequences can be generic and run on all platforms, or vary according to
platform.  This allows developers to specialize as needed.

Smokey implements support for platform specialization via directory precedence.
It first looks for the \filename{Main.lua} and \filename{Main.plist} pair in a
subdirectory with the same name as the DUT platform.  Failing that, Smokey
searches the top-level sequence folder.  This allows a sequence to specialize
for particular platforms and provide a fallback implementation where
applicable.  Alternatively, this also allows sequences to support all platforms
with a single implementation if no platform directories are used.  These use
cases are illustrated by the three directory listings in figure
\ref{fig:FolderLayout}.

User files can be platform-specific as well.  This is done by maintaining file
variations with the same name, but in different directories.  Like the Lua and
plist files, files in the top-level sequence folder are considered
platform-agnostic, whereas specialized versions should live in separate folders
per platform.  The Smokey file locator API functions support this
convention.\footref{fn:LocatorFunctions}

\subsubsection{Deprecated Sequence Folder Layout}

Older versions of Smokey required a folder layout slightly different from the
current design.  That layout is now deprecated in order to support new sequence
features, but is documented here for historical purposes.

Figure \ref{fig:DeprecatedLayoutTransition} illustrates the translation between
the old and new layout styles.  The difference lies in the moving and renaming
of the Lua and plist files into their own platform-specific directory.
Migration is a matter of a few filesystem operations.

\begin{figure}[h]

	\begin{SideBySideGrid}

		\HeadingRow{Deprecated Style}{New Style}

	\NextRow

		% Old Style
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\File{.FactoryLogs...}
			\File{\param{platform}.lua}
			\File{\param{platform}.plist}
			\File{PDCA.plist}
			\File{Smokey.log}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		% New Style
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\Directory{\param{platform}}{
				\File{Main.lua}
				\File{Main.plist}
			}
			\File{.FactoryLogs...}
			\File{Earthbound.sig}
			\File{PDCA.plist}
			\File{Smokey.log}
		}
		\end{NestedDirectoryTree}

	\LastRow
	\end{SideBySideGrid}

	\caption{Folder Layout Transition}
	\label{fig:DeprecatedLayoutTransition}

\end{figure}

\subsection{Sequence Schema}
\label{sec:SequenceSchema}

\subsubsection{Schema}

Smokey's sequence property list is built on top of Apple's ASCII plist format.
A schema comprised of predefined keys and values is defined in order to
describe both Smokey's behavior as well as the sequence's behavior.  Figure
\ref{fig:SequenceSchema} shows the layout of a simple plist.

Smokey's schema is rooted at the top of the plist hierarchy.  Properties
generally fall into one of two categories.  \jargon{Control properties} are
stored in the root.  \jargon{Test item properties} start at the root, but use a
recursive definition.  The meaning of these properties are detailed in section
\NumNameRef{sec:SmokeyProps}.

\begin{figure}[h]

	\begin{CenteredPropertyList}{20em}
	\Root{Main.plist}{
		\String{SequenceName}{N78 QT Demo}
		\String{SequenceVersion}{20121017}
		\Number{SchemaFormat}{1}
		\String{BrickRequired}{1A}
		\String{BehaviorOnFail}{StopAfterFailedAction}
		\Number{NumberOfTimesToRun}{1}
		\Array{Tests}{
			\Dictionary{Item 0}{
				\String{TestName}{NAND Test}
				\String{ActionToExecute}{NandTest}
				\Number{NumberOfTimesToRun}{1}
			}
			\Dictionary{Item 1}{
				\String{TestName}{Gyro Test}
				\String{ActionToExecute}{GyroTest}
				\Number{NumberOfTimesToRun}{1}
			}
			\Dictionary{Item 2}{
				\String{TestName}{WiFi/BT Test}
				\String{ActionToExecute}{WifiBtTest}
				\Number{NumberOfTimesToRun}{1}
			}
			\Dictionary{Item 3}{
				\String{TestName}{Front Camera Test}
				\String{ActionToExecute}{FrontCameraTest}
				\Number{NumberOfTimesToRun}{1}
			}
			\Dictionary{Item 4}{
				\String{TestName}{Shutdown}
				\String{ActionToExecute}{Shutdown}
				\Number{NumberOfTimesToRun}{1}
			}
		}
	}
	\Annotate{1}{5}{Control}
	\Divider{5}
	\Annotate{6}{27}{Tests}
	\end{CenteredPropertyList}

	\caption{Sequence Schema Example}
	\label{fig:SequenceSchema}

\end{figure}

\subsubsection{Structure}

The structure of test ordering in Smokey centers around the concepts of actions
and test items.  An \jargon{action} is a piece of Lua code that Smokey can
invoke.  A \jargon{test item} is a node in the plist structure with properties
identifying how the sequencer treats an action.  In effect, test items are
consumers of actions, and the Smokey sequencer is a consumer of test items.
Note that a particular action is allowed to appear in more than one test item.

The design of the schema is intended to produce nearly flat plist files for the
common case where a sequence is a linear list of test items.  In more complex
scenarios, actions can be grouped and nested by layering test items.  This is
done by defining a test item property rather than an action property inside a
test item.

\subsection{Sequence Flow}
\label{sec:SeqFlow}

When Smokey executes a sequence, it handles a variety of tasks related to
preparing the DUT, executing actions, logging results, and reporting progress.
It will be important to know how these activities are arranged in order to
understand how sequence actions fit in.

\subsubsection{Pre-Flight Phase}

Before running a sequence, Smokey does the following:

\begin{Process}

	\item Process command line options.

	\item Check for autostart conditions.

	\begin{Process}

		\item If the autostart option is set, configure the
		\nvram{boot-command} NVRAM variable.\footnote{See section
		\NumNameRef{sec:Autostart} for other behavior implied by
		autostart.}
		
		\item If the autostart option is not set, continue normally.

	\end{Process}

	\item Load the sequence's Lua script and parse the property list file.

	\item Apply remaining command line and NVRAM options.

	\item Check for existing results.  Abort if found.

	\item Open log files.

	\item Record the start of the sequence.

	\item Initialize hardware and EFI software features implied by the
	sequence properties.

	\item If \prop{BrickRequired} is set, wait for an external charger to
	be connected.  The wait time is indefinite.

\end{Process}

\subsubsection{Sequence Execution Phase}

\begin{Process}[resume]

	\item Traverse the \prop{Tests} array at the root of the plist in order
	and process each element.  This is a pre-order, depth-first traversal.

	\begin{itemize}

		\item Failure handling occurs during this phase.  Fatal
		failures will force Smokey to jump to the next phase.

		\item If the test item defines \prop{ActionToExecute}, perform
		that action.

		\begin{Process}

			\item Flush pending file output

			\item Invoke the named Lua function

			\item Record the result of calling the function

		\end{Process}

		\item If the test item defines \prop{Tests}, recurse into that
		array.

	\end{itemize}

\end{Process}

\subsubsection{Post-Flight Phase}

\begin{Process}[resume]

	\item Write complete results.

	\item Flush pending file output.

	\item If autostarted, reboot.

\end{Process}

\subsubsection{Periodic Tasks}

While a sequence is running, Smokey only has control of the system between
sequence actions.  That time is used to handle various repeating management
tasks.

\begin{Descriptive}

	\item[Charger Check] If \prop{BrickRequired} is set and a disconnect is
	detected on the external charger, wait for the charger to be
	reconnected.  The wait time is indefinite.

\end{Descriptive}

\subsection{Sequence Processing}

\subsubsection{Test Item Naming}
\label{subsec:TestItemNaming}

For reporting purposes, Smokey requires a name for each test item in the
sequence that defines \prop{ActionToExecute}.  If the \prop{TestName} property
is set, it is used as the test name.  Otherwise, the value of
\prop{ActionToExecute} is the default.

Note that the sequence properties must be configured to avoid duplicate test
names.  For instance, if several test items have the same
\prop{ActionToExecute}, each item must have a different \prop{TestName}.
Smokey will preemptively abort a sequence if it detects a naming conflict.

Test items without \prop{ActionToExecute} produce no results or data, so they
do not require a test name.

\subsubsection{Node Numbering}

For tracking and internal purposes, Smokey represents the sequence as a tree
and automatically gives each node a number.  Like the sequence execution phase,
assignment is done with a pre-order, depth-first traversal.  This produces node
numbers that read like line numbers when the sequence is printed in outline
form.

The root of the plist file is always node one.

Node number assignment will change as the sequence changes.  There is no
support for specifying a node's number.

\subsubsection{Number of Test Item Iterations}

The number of iterations per test item is the mathematical product of
\prop{NumberOfTimesToRun} at the test item in question and all test items
immediately above it.  One result is recorded each time the sequencer traverses
into the test item.

For example, consider a sequence with \prop{NumberOfTimesToRun} at the plist
root set to 2 and a test item with \prop{NumberOfTimesToRun} set to 3 and
\prop{ActionToExecute} defined.  Smokey will process the test item 6 times in
total.  The sequencer will traverse into the test item twice.  The first
traversal will record results for iterations 1 through 3.  The second traversal
will record results for iterations 4 through 6.

\subsection{Pass/Fail Criteria of Actions}
\label{sec:PassFailCriteria}

Smokey takes into account various Lua code return paths when assessing the
result of an action.  Scripts can take advantage of this to silently stop the
sequence or return verbose failure information for later failure analysis.

\subsubsection{Function Return Value}

An action's return value is the primary indicator of success.  Table
\ref{tab:FunctionReturnValues} shows the ways of functionally reporting pass
and fail that Smokey supports.

\begin{table}[h]

	\begin{ValueTable}
		 \keyword{nil}   & Nil     & Passed      \\
		 \keyword{true}  & Boolean & Passed      \\
		 \keyword{false} & Boolean & Failed      \\
		 All Others      &         & Unsupported \\
	\end{ValueTable}

	\caption{Functional Return Values from Actions}
	\label{tab:FunctionReturnValues}

\end{table}

Note that, in the Lua language, \keyword{nil} can be returned explicitly with a
\keyword{return} statement or implicitly by ending a code block without a
\keyword{return}.

\subsubsection{Exceptions}

Any exceptions not caught by actions themselves will be caught by the
sequencer.  Smokey considers this a failure and acts accordingly.

Note that the data thrown with an exception will be logged.  If an action
chooses to throw an exception, it is recommended that a helpful error string be
used.

\subsubsection{Data Results Cascading}
\label{sec:DataCascading}

Parametric data is considered an integral component of an action's
result.\footnote{See section \NumNameRef{sec:ParametricData}.} When bad data is
reported,\footnote{See \func{ReportData} in section
\NumNameRef{sec:SmokeyApi}.} Smokey cascades the data failure upwards and fails
the action.  This, in turn, makes failure the overall sequence result.

In contrast to uncaught exceptions, data failure is a silent event.  Smokey
will make note of it, but there will be no interruption of execution.

\subsection{Failure Handling}
\label{sec:FailureHandling}

\subsubsection{Sequence Excursions}

Once an action's result has been assessed, Smokey decides whether to continue
the test sequence.

\begin{Descriptive}

	\item[Test Passed] Continue the sequence in the defined test order.

	\item[Test Failed] The current \prop{ActionToExecute} failed or a
	subtest in \prop{Tests} propagated an error.  Call
	\prop{FailScript},\footnote{See section
	\NumNameRef{sec:HandlingFailures}.} then divert the test order based on
	the test item configuration.

\end{Descriptive}

The test item property \prop{BehaviorOnFail} defines Smokey's exact failure
handling.

\begin{Definition}

	\item[KeepGoing] Ignore the failure and continue the rest of the
	sequence.  No failure is propagated to the parent test.

	\item[StopAfterFailedAction] Stop the current test item immediately and
	propagate the failure upwards.

	\item[StopAfterFailedIteration] Execute the remaining test items in the
	current iteration.  Afterwards, stop the current test and propagate the
	failure upwards.

	\item[StopAfterFailedTest] Execute the remainder of the current
	iteration and complete the remaining iterations.  Afterwards, propagate
	the failure upwards.

\end{Definition}

Tests that define the \prop{ActionToExecute} property but not \prop{Tests} will
behave identically for \propval{StopAfterFailedAction} and
\propval{StopAfterFailedIteration}.  For either value, Smokey stops the test
immediately and notifies the parent test of the failure.  There are effectively
only three behaviors in this case.

Tests that define the \prop{Tests} property have four distinct failure
behaviors, as described above.  After each subtest immediately defined in the
\prop{Tests} array, Smokey acts upon subtest failure according to
\prop{BehaviorOnFail}.  Developers have the option of stopping the test
immediately, deferring the stop until the end of the current iteration through
\prop{Tests}, or waiting for all iterations to complete.  In these three cases,
the failure will be reported to the parent test so that it can respond
according to its own \prop{BehaviorOnFail}.  A fourth option is to complete
testing without propagating the failure upwards.

The \prop{BehaviorOnFail} property is inherited.  The required definition at
the root of the test sequence sets the default failure behavior of all tests.
Individual tests that specify their own \prop{BehaviorOnFail} can override the
inherited value and set the failure behavior for themselves as well as all
tests beneath them.

The test sequence definition can locally override the inherited value of
\prop{BehaviorOnFail} with the \prop{ThisBehaviorOnFail} property, whose values
and meanings exactly match those of \prop{BehaviorOnFail}.  The override
applies only to the test that defines it and it is not inherited.  Both
\prop{BehaviorOnFail} and \prop{ThisBehaviorOnFail} may be defined in the same
test to set different behaviors for parent and child tests in the sequence.

\subsubsection{Handling Failures During a Sequence}
\label{sec:HandlingFailures}

Sequences can choose to handle failures---whether for clean-up purposes or to
manage internal state---by defining the \prop{FailScript} property.  Smokey
will invoke the named Lua function when the sequencer assesses a test
failure.\footnote{See section \NumNameRef{sec:SequenceFunctions}.} This happens
for all values of \prop{BehaviorOnFail}, including \propval{KeepGoing}.

Because test items can be nested, more than one \prop{FailScript} may be
invoked.  The first one to be executed would be at the test item that failed.
The next would be the one in the test item immediately outside of that nested
test item.  And so on, from the epicenter to the plist root.  Any test items
along this path without a \prop{FailScript} definition will be ignored.

The invocation of \prop{FailScript} happens as soon as an error is detected.
For tests with \prop{ActionToExecute}, this happens as soon as the action
fails.  For tests with \prop{Tests}, it happens when the failure propagation
reaches a subtest.

\subsubsection{Failures During Periodic Tasks}

Any failure during a periodic task is considered fatal.  If \prop{FailScript}
is defined at the plist root, that Lua function shall be invoked.  Thereafter,
the sequence execution phase is aborted.

\subsection{Test Results}

\subsubsection{Results Tracking}

During the course of a sequence, Smokey tracks results individually.  There is
a result recorded for each iteration of each test item.  Additionally, there is
an overall result based on the individual results. 

All results are initialized during the pre-flight phase to ``incomplete''.
Pass and fail are recorded as the sequence progresses.  The overall result is
recorded once the last test item is finished or the sequence is aborted due to
failure.

\subsubsection{Test Results Naming}

Names for results are automatically generated by combining the test item name
with the iteration number.\footnote{See table
\NumNameRef{tab:IndividualTestResults} on page
\pageref{tab:IndividualTestResults}.}

\subsubsection{Test Data Naming}

Smokey can collect parametric data and limits from each test item.\footnote{See
section \NumNameRef{sec:ParametricData}.}  The data's name is specified by the
sequence script, but Smokey will make the name unique by including the name of
the test item and the iteration number.\footnote{See table
\NumNameRef{tab:TestData} on page \pageref{tab:TestData}.}

\subsubsection{Propagation of Results}

To maintain consistency, the overall sequence result is computed from the
individual test item results.  Therefore, any failure at the item level forces
the overall sequence result to fail.  Incomplete tests are treated as
failures.

\subsection{Sequence State Saving}
\label{sec:SeqStateSaving}

\subsubsection{Sequence Continuation}

A unique feature of Smokey compared to canonical Lua scripting is the built-in
ability to pause a sequence and continue at a later time.  This means that any
action can reboot the DUT, power cycle, or otherwise interrupt the system and
Smokey will know how to pick up from the last test item without losing results.

As mentioned in section \NumNameRef{sec:TestItemProperties}, this behavior is
enabled by setting \prop{BehaviorOnAction} to \propval{SaveState}.  It is
effective only during the test item in which the property is defined.  If the
test item's action does not interrupt the DUT, Smokey will automatically clear
the continuation point.

\subsubsection{Requirements}

The DUT must meet the requirements for autostart.\footnote{See section
\NumNameRef{sec:Autostart}.}

\subsubsection{Serialization}

When enabled, Smokey performs the following immediately before invoking
\prop{ActionToExecute}.

\begin{Descriptive}

	\item[Set Continuation Point] Mark the sequence to continue at the test
	item immediately following the one defining \prop{BehaviorOnAction}.

	\item[Save Smokey State] Write all internal Smokey data to
	\filename{State.txt}.\footnote{See section
	\NumNameRef{sec:FileOutput}.}

	\begin{itemize}

		\item Save the state of the sequence traversal.

		\item Save all test results.

	\end{itemize}

	\item[Configure Autostart] Set Smokey to run automatically at next boot.

	\begin{itemize}

		\item Save the current \nvram{boot-args} and
		\nvram{boot-command} NVRAM variables.\footnote{See section
		\NumNameRef{sec:Autostart} for a description of how NVRAM
		variables are used by Smokey.}

		\item Add a bare \nvarg{smokey} argument to \nvram{boot-args}.

		\item Set \nvram{boot-command} to \nvarg{diags}.

	\end{itemize}

\end{Descriptive}

\subsubsection{Resurrection}

When Smokey is invoked from the command line, it checks for the existence of a
saved state before loading the user-specified sequence.  If one is found, the
state is automatically resurrected and that state's sequence will be continued.

\begin{Descriptive}

	\item[Load State Data] Resurrect the data saved during serialization.
	\begin{itemize}

		\item Reload all internal Smokey variables.

		\item Reload all test results.

	\end{itemize}

	\item[Reset Autostart] Disable the configuration from serialization.

	\begin{itemize}

		\item Restore \nvram{boot-args} and \nvram{boot-command}.

	\end{itemize}

	\item[Delete Continuation Point] Clear the state file so that it can be reused.

\end{Descriptive}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Design for Factory Use}
\label{sec:DesignForFactoryUse}

\subsection{Objectives for Factory Use}

Smokey's objective is to automate testing for manufacturing scenarios.
Primarily, this means enabling a DUT to run commands on its own and emit data
to factory processes.  Several design decisions were made and features
implemented to support these goals:

\begin{itemize}

	\item Support for multiple, user-defined sequences allows use both on
	and off the manufacturing line.

	\item Sequences are maintained separately from EFI diags and therefore
	don't require intensive validation (e.g., on all stations) before
	roll-out.

	\item Sequences are stored on the filesystem to enable identical
	deployment on a large number of test units.

	\item Sequence execution is logged to a file for failure analysis.

	\item Results are emitted in DCSD's format for PDCA.

	\item Execution can be triggered via NVRAM.

	\item Timestamps identify hangs, performance issues, and process excursions.

\end{itemize}

\subsection{Station Behavior}

In traditional station software, a station ID is used for reporting results and
log collection.  The name of the station is collaboratively chosen by the
station DRI, program managers, and the factory software team.  A numeric
identifier serves to codify the station's place within the factory process.

Smokey isn't meant to directly replace station software because it wasn't
designed to plug into the manufacturing infrastructure.  However, it can be
used to control those aspects of a station that affect the state of the DUT.

Station behavior is enabled by giving sequences specific, reserved names.
Presently, the sequence names below are reserved for specific factory station
activities.  Consult an EPM or TDL for the most up-to-date list for a specific
project.

\begin{itemize}

	\item Wildfire (ID 0xB4)

\end{itemize}

The list of station-related behavior in Smokey follows:

\begin{itemize}

	\item Control bits

\end{itemize}

Sequences that do not have any of the reserved names do not receive special
treatment.  Use of reserved sequence names for non-station-related activities
is highly discouraged.

\subsection{Control Bits}

Control bits are a process control mechanism used to track test coverage in the
factory.  Because coverage is directly related to final product quality,
control bits can only be manipulated with the proper clearance.  Smokey strives
to ensure the security of control bits by acting as a middleman between
sequences and the DUT.

For sequences associated with a station ID, the respective control bit is
updated as the sequence executes in order to record gross progress.  This
generally happens alongside the writing of results to the filesystem, but may
occur less frequently because the granularity of control bit states is coarse.

The control bit state can be used as a rough indicator of progress.

\begin{Definition}

	\item[Untested] Sequence has not been invoked or Smokey aborted early.

	\item[Incomplete] Smokey processed the sequence and has recorded its
	start.

	\item[Pass \textnormal{or} Fail] Sequence is complete.

\end{Definition}

Writing to control bits can be disable by the \prop{ControlBitAccess} property.
Remember to keep this in mind if a control bit value has an unexpected value.

\subsection{Parametric Data}
\label{sec:ParametricData}

In addition to the procedural information provided by test results, an
important aspect of factory testing is the collection of measurements and
numeric artifacts.  This information is called \jargon{parametric data} because
it carries metadata such as names, limits, and success.  PDCA actually uses
parametric data for all factory test output, but Smokey limits the usage of
this term to the ancillary output from tests.

Smokey provides the \func{ReportData} and \func{ReportAttribute} functions
specifically to allow tests to produce parametric data for PDCA.\footnote{See
sections \NumNameRef{sec:DataCascading} and \NumNameRef{sec:SmokeyApi}.}
Consequently, the presence of parametric data is dependent on a test sequence's
intent and implementation.  Smokey produces no parametric data on its own.

\subsection{Log Collection}

\subsubsection{DUT Identifier}

Reporting to the factory requires that data be uniquely tied to a DUT.  Smokey
identifies the device under test by either the system serial number
\nvram{SrNm} or the MLB serial number \nvram{MLB\#} in syscfg, depending on
\prop{SerialNumberSource}.\footnote{See section \NumNameRef{sec:SmokeyProps}.}

\subsubsection{File Output for LogCollector}
\label{sec:LogCollectorFiles}

Smokey's file output is designed to be compatible with LogCollector, with
emphasis on being human readable.  Towards that goal, files are largely
ASCII-compatible and Smokey's output is split across several
files.\footnote{See section \NumNameRef{sec:FolderLayout}.}  All files in a
sequence's directory will be saved to PDCA.

Two files will be of interest to those investigating issues with log
collection.  Refer to section \NumNameRef{sec:FileOutput} for more details
about their contents and the sequence properties that control them.

\begin{Definition}

	\item[PDCA.plist] The main output file for LogCollector's consumption.
	Smokey writes results to this file in a PDCA-specific schema.

	\item[.FactoryLogsWaitingToBeCollected] Semaphore file for
	LogCollector.  Indicates whether factory data is available for
	collection.

\end{Definition}

\subsubsection{File Output for Earthbound}
\label{sec:EarthboundFiles}

For burn-in testing, Earthbound can substitute for LogCollector and gather
Smokey's PDCA output.  The set of required files overlaps the LogCollector
scenario.

\begin{Definition}

	\item[PDCA.plist] Same as for LogCollector.

	\item[Earthbound.sig] Security signatures required by Earthbound.
	Collected files are validated using this file before being accepted for
	PDCA.

\end{Definition}

\subsection{Encoding Test Results and Data}
\label{sec:TestResults}

Information reported to the PDCA system includes the results for all tests as
well as the data gathered by those tests.  These are all stored in plist format
using DCSD's PDCA schema.

Because of the schema, all output is represented as test results.  The PDCA
properties \prop{testname}, \prop{subtestname}, and
\prop{subsubtestname}\footnote{The PDCA database reports \prop{testname},
\prop{subtestname}, and \prop{subsubtestname} as one concatenated string.} are
used as identifiers for individual tests and data.  The \prop{result} and
\prop{failure\_message} properties, amongst others, encode sequence output.
Specific values are described in tables
\ref{tab:OverallSequenceResult}--\ref{tab:TestData}.

Note that table \NumNameRef{tab:EfiCommandFailure} is a special case for
reporting purposes.  Unlike the others, it is not a function of the sequence
definition, but is generated for test items that fail due to EFI diags command
errors.  This is in addition to the output described in table
\NumNameRef{tab:IndividualTestResults}.

Also note that \prop{result} and \prop{failure\_message} in table
\NumNameRef{tab:TestData} are influenced by both limits and run-time overrides
during the reporting API call.\footnote{See section
\NumNameRef{sec:SmokeyApi}.}  Seemingly good data may be forcibly failed at run
time.

% TODO: Is it worth talking about the ordering of PDCA.plist items?
% <rdar://problem/14719547> Smokey Error Reporting: Report something other than "Iteration 1" for command failures
% <rdar://problem/14260890> Smokey Error Reporting: Report something other than "Iteration 1" for command failures

\begin{table}[p]

	\begin{PdcaTable}[Pass & Fail & Incomplete]
		\prop{overallResult} & \mc{1}{``PASS''} & \mc{2}{``FAIL''} \\
	\end{PdcaTable}

	\caption{Overall Sequence Result}
	\label{tab:OverallSequenceResult}

\end{table}

\begin{table}[p]

	\begin{PdcaTable}[Pass & Fail & Incomplete]
		\prop{testname}         & \mc{3}{Test item's \prop{TestName} or \prop{ActionToExecute} value}  \\
		\prop{subtestname}      & \mc{3}{``Iteration '' + iteration number}                            \\
		\prop{subsubtestname}   & \mc{3}{Not used}                                                     \\
		\prop{result}           & \mc{1}{``PASS''} &  \mc{2}{``FAIL''}                                 \\
		\prop{failure\_message} & \mc{1}{Not used} &  \mc{1}{Actual message} &  \mc{1}{``Incomplete''} \\
	\end{PdcaTable}

	\caption{Individual Test Results}
	\label{tab:IndividualTestResults}

\end{table}

\begin{table}[p]

	\begin{PdcaTable}[Pass & Fail & Incomplete]
		\prop{testname}         & \mc{3}{Test item's \prop{TestName} or \prop{ActionToExecute} value} \\
		\prop{subtestname}      & \mc{3}{EFI command name}                                            \\
		\prop{subsubtestname}   & \mc{3}{``Iteration '' + iteration number}                           \\
		\prop{result}           & \mc{1}{Not used} &  \mc{1}{``FAIL''}       & \mc{1}{Not used}       \\
		\prop{failure\_message} & \mc{1}{Not used} &  \mc{1}{Actual message} & \mc{1}{Not used}       \\
	\end{PdcaTable}

	\caption{EFI Command Failure}
	\label{tab:EfiCommandFailure}

\end{table}

\begin{table}[p]

	\begin{PdcaTable}[No Limits & Within Limits & Exceed Limits]
		\prop{testname}         & \mc{3}{Test item's \prop{TestName} or \prop{ActionToExecute} value} \\
		\prop{subtestname}      & \mc{3}{Sequence's data name}                                        \\
		\prop{subsubtestname}   & \mc{3}{``Iteration '' + iteration number}                           \\
		\prop{value}            & \mc{3}{Sequence's data value}                                       \\
		\prop{units}            & \mc{3}{Sequence's data units (if provided)}                         \\
		\prop{lowerlimit}       & \mc{1}{Not used} &  \mc{2}{Data lower limit (if provided)}          \\
		\prop{upperlimit}       & \mc{1}{Not used} &  \mc{2}{Data upper limit (if provided)}          \\
		\prop{result}           & \mc{2}{``PASS''} &  \mc{1}{``FAIL''}                                \\
		\prop{failure\_message} & \mc{2}{Not used} &  \mc{1}{Automatic}                               \\
	\end{PdcaTable}

	\caption{Test Data}
	\label{tab:TestData}

\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Using Smokey}

\subsection{Smokey Command Line Arguments}
\label{sec:CmdArgs}

Smokey is command line driven and only supports certain combinations of
arguments.

In the following descriptions, options are prefixed by double dashes.  Options
shown in square brackets may be omitted.  Ellipses are used to indicate that
additional options may be specified, but omitted from this text for brevity.

Common values to be supplied by the user are defined below:

\begin{Definition}

	\item[Sequence] The name of a sequence.  Smokey searches for this
	folder name in the standard location.  Must contain files appropriate
	for the DUT platform.

	\item[TestName] The name of a test item.  This corresponds to the
	effective test name, based on the \prop{TestName} and
	\prop{ActionToExecute} properties.\footnote{See section
	\NumNameRef{subsec:TestItemNaming}.}

\end{Definition}

\subsubsection{Print Version}

\begin{CommandLine}
smokey --version
\end{CommandLine}

Show the build date and version.  There will be separate lines of output for
each component of the program.  Please include this information when filing
bugs or requesting help.

\subsubsection{Print Command Line Help}

\begin{CommandLine}
smokey --help
\end{CommandLine}

Print a list of all supported command line options.  Some options may not be
intended for general use.  Not all option combinations are valid.

\subsubsection{Run a Sequence}

\begin{CommandLine}
smokey ~\param{Sequence}~ [--clearstate] --run
\end{CommandLine}

Execute a sequence from a fresh state.

If there is an existing saved state, specifying \cmdline{--clearstate} ensures
that the saved state is not used.

\subsubsection{Continue from a Saved State}

\begin{CommandLine}
smokey [--retainstate] --run
\end{CommandLine}

If a saved state is available, continue from where it left off.  Most other
command line options are ignored.

Typically, the saved state is deleted when continuing a sequence so that
progress moves forward.  If the state should be retained to later re-run from
the same point, \cmdline{--retainstate} can be specified.  Note that continuing
twice from the same saved state may not produce the same file output as normal.
Also note that this option won't prevent a new state from overwriting the
current state.

\subsubsection{Sanity Check a Sequence}

\begin{CommandLine}
smokey ~\param{Sequence}~
\end{CommandLine}

Smokey will load the sequence script and plist files to check syntax and
settings.  No actions beyond that are taken.

\subsubsection{Perform a Dry Run on a Sequence}

\begin{CommandLine}
smokey ~\param{Sequence}~ [--clearstate] --dryrun
\end{CommandLine}

A dry run is the same as a normal run, but actions are not invoked.  This is
useful to make sure basic issues in Smokey are not causing sequence failures.

\subsubsection{Get Information about a Sequence}

\begin{CommandLine}
smokey ~\param{Sequence}~ --sequence
\end{CommandLine}

\begin{CommandLine}
smokey ~\param{Sequence}~ --summary
\end{CommandLine}

The first command dumps the entire sequence definition whereas the second
summarizes the actions that will be taken.  They can be used to verify the
structure of the sequence plist file.  See section \ref{sec:SeqOut} for more
details.

\subsubsection{Get Information about Sequence Code}

\begin{CommandLine}
smokey ~\param{Sequence}~ --dependencies
\end{CommandLine}

Show a list of all modules, submodules, and external code statically loaded by
\func{require}, \func{loadfile}, and \func{dofile}, as well as the main
sequence code file.\footnote{See section
\NumNameRef{sec:ExternalCodeDependencies}.}  See section \ref{sec:SeqOut} for
details on how the information is presented.

\subsubsection{Clear Existing Saved State}

\begin{CommandLine}
smokey --clearstate
\end{CommandLine}

Erase the sequence state saved by \prop{BehaviorOnAction}.  No actions are
taken, and no errors reported, if there is no state presently defined.

\subsubsection{Clear Existing Sequence Results}

\begin{CommandLine}
smokey ~\param{Sequence}~ --clean
\end{CommandLine}

Clear the output files\footnote{See section \NumNameRef{sec:FileOutput}.} of
\param{Sequence} such that Smokey will later think that \param{Sequence} is
being run for the first time.  Can be combined with \cmdline{--run} on the same
command line.

Restricted to DEV-fused devices only.  This feature is intended for engineering
purposes only.

\subsubsection{Trigger Smokey Externally (Autostart)}

\begin{CommandLine}
smokey ... --autostart
\end{CommandLine}

Enable autostart behavior.\footnote{See section \NumNameRef{sec:Autostart}.}
Implies \cmdline{--run}.

\subsubsection{Manually Select Tests to Run}

\begin{CommandLine}
smokey ~\param{Sequence}~ ... --test ~\param{TestName}~
\end{CommandLine}

\begin{CommandLine}
smokey ~\param{Sequence}~ ... --test ~\param{TestName}~,~\param{TestIterations}~
\end{CommandLine}

Run only the tests specified and disable all other test items in the sequence.

The \cmdline{--test} option can be used multiple times within the same command
line.  This can be used to select a single test, or a subset of tests.

The \param{TestIterations} argument is a suboption for setting
\prop{NumberOfTimesToRun}.  When omitted, it defaults to 1.

\subsubsection{Override Property Value}

\begin{CommandLine}
smokey ~\param{Sequence}~ ... ~\param{PropName}~=~\param{PropVal}~
\end{CommandLine}

\begin{CommandLine}
smokey ~\param{Sequence}~ ... Node[~\param{NodeId}~].~\param{PropName}~=~\param{PropVal}~
\end{CommandLine}

Properties for any part of a sequence may be temporarily overridden at the
command line.  Multiple overrides may be used on a single command line.

Without a node specifier, properties at the root of the sequence will be
modified.  Both styles are subject to schema validation against the
schema.\footnote{See sections \NumNameRef{sec:SequenceSchema} and
\NumNameRef{sec:SmokeyProps}.}

The value for \param{NodeId} can be obtained from the output of
\cmdline{--sequence} or \cmdline{--summary}.

\subsubsection{Overriding Test Arguments}
\label{sec:SeqCmdLineArguments}

\begin{CommandLine}
smokey ~\param{Sequence}~ ... --args '~\param{Arg}~=~\param{Val}~'
\end{CommandLine}

\begin{CommandLine}
smokey ~\param{Sequence}~ ... --args '~\param{Arg1}~=~\param{Val1}~,...,~\param{ArgN}~=~\param{ValN}~'
\end{CommandLine}

\begin{CommandLine}
smokey ~\param{Sequence}~ ... --testargs '~\param{TestName}~,~\param{Arg}~=~\param{Val}~'
\end{CommandLine}

\begin{CommandLine}
smokey ~\param{Sequence}~ ... --testargs '~\param{TestName}~,~\param{Arg1}~=~\param{Val1}~,...,~\param{ArgN}~=~\param{ValN}~'
\end{CommandLine}

Overlay the given argument definition on top of any arguments predefined by the
sequence.\footnote{See section \NumNameRef{sec:TestArguments}.} Both
\cmdline{--args} and \cmdline{--testargs} may appear multiple times on a single
command line.

Global arguments are declared by \cmdline{--args} and specified as a
comma-separated list of key-value pairs in Lua table initializer syntax.
Arguments for a single test item are declared by \cmdline{--testargs} and have
the same format, but also require the test item name, which may come from
\prop{TestName} or \prop{ActionToExecute}.

Due to the layers of string parsing between the shell and Smokey, arguments may
need to be wrapped with a combination of single, double, and Lua-specific
square bracket quotes.

\subsection{Autostart}
\label{sec:Autostart}

On Darwin mobile platforms, the DUT can be configured to execute a Smokey
sequence upon booting into EFI diags.  This allows automatic test execution on
the device, as well as integration with other test environments.  Smokey
supports this feature primarily to enable EFI-based testing from inside iOS,
but it can be used for automated testing to a limited degree.

\subsubsection{Prerequisites for Autostart}

Autostart is effected by a combination of device settings and EFI diags
configuration.  The following requirements must be met.

\begin{Descriptive}

	\item[NVRAM] The DUT must support iOS-style NVRAM variables in EFI
	diags.  This means that the firmware driver must be available and the
	DUT must support this hardware feature.

	\item[EFI Diags Boot Configuration] On the EFI diags side, Smokey needs
	to be part of the boot process.  This boils down to integrating the
	\cmdline{smokey} command into the shell's autostart configuration.

\end{Descriptive}

\subsubsection{Configuring EFI Diags for Autostart}

Smokey leverages the EFI command shell's built-in support for running commands
at boot based on the \nvram{boot-args} NVRAM variable.  For example, instead of
going to the command line, the shell can launch the \cmdline{smokey} command
when \nvarg{smokey} is in \nvram{boot-args}.  This configuration must be made
in the EFI diags image and is not something a Smokey user can do on their own.

In a pinch, autostart behavior can be partly emulated, as shown in the command
line below.\footnote{See section \NumNameRef{sec:CmdArgs}.}  This would need to
be manually typed into the EFI shell.

\begin{CommandLine}
smokey ~\param{Sequence}~ --autostart
\end{CommandLine}

\subsubsection{Configuring DUT for Autostart}

Once prerequisites are met, the following NVRAM variables can be set to kick
off a Smokey sequence.

\begin{Descriptive}

	\item[boot-args] The \nvarg{smokey} argument must be present.  The
	other arguments in this variable are beyond the scope of this document.

	\item[boot-command] Must be set to \nvarg{diags}.  If this is not
	possible, a special cable or dongle will be required to force the DUT
	to boot into EFI diags.

	\item[auto-boot] Must be set to \nvarg{true}.

\end{Descriptive}

Refer to section \NumNameRef{sec:ClearingAutostart} for information on how to
reverse this process.

\subsubsection{Smokey NVRAM Argument}

The \nvarg{smokey} argument in \nvram{boot-args} is a comma-separated list that
is transformed into a Smokey command line.

The decision was made to put \nvarg{smokey} in \nvram{boot-args} instead of its
own NVRAM variable because doing so facilitates deployment:  The
\nvram{boot-args} variable can be easily set from PurpleRestore, whereas other
variables are not well supported.  DUTs can be restored with a root containing
a sequence and be configured to run it on the next reboot using a single tool.

The \nvram{boot-args} syntax is shown below.

\begin{Setting}
boot-args = "... smokey ..."
\end{Setting}

\begin{Setting}
boot-args = "... smokey=~\param{Sequence}~ ..."
\end{Setting}

\begin{Setting}
boot-args = "... smokey=~\param{Sequence}~,~\param{Arg1}~,...,~\param{ArgN}~ ..."
\end{Setting}

There is currently only one universal parameter to \nvarg{smokey}.

\begin{Definition}

	\item[Sequence] The name of the sequence to execute.  This is ignored
	and may be omitted when Smokey will be continuing from a saved
	state.\footnote{See section \NumNameRef{sec:SeqStateSaving}.}  However,
	omission is an internal use case and users typically must specify a
	sequence name.

\end{Definition}

When the EFI diags shell invokes Smokey, the \nvarg{smokey} variable is split
at any commas and bookended with \cmdline{smokey} and \cmdline{--autostart}.
For the long \nvram{boot-args} example above, the conversion would result in
the following:

\begin{Setting}
smokey ~\param{Sequence}~ ~\param{Arg1}~ ... ~\param{ArgN}~ --autostart
\end{Setting}

The EFI diags shell will invoke the effective command line as if it were
manually entered at the console.

\subsubsection{Autostart Behavior}

As mentioned in the code path description in section \NumNameRef{sec:SeqFlow},
the prerequisite for autostart behavior is the \cmdline{--autostart} option on
the command line, which is a consequence of having \nvarg{smokey} in
\nvram{boot-args}.

When autostart conditions are met, Smokey will process and execute the
configured test sequence.  Additionally, the following tasks are performed at
the start of the test cycle:

\begin{itemize}

	\item Remove the \nvarg{smokey} argument from \nvram{boot-args}.  This
	is done by the EFI diags shell.  External processes can take the
	removal as a sign that the DUT finished booting and has proceeded
	onwards to the test sequence.

	\item Configure the DUT to run iOS on the next reboot.  Smokey does
	this by setting the \nvram{boot-command} NVRAM variable to
	\nvarg{fsboot}.

\end{itemize}

Automatic start implies automatic reboot.  Smokey will reboot the DUT at the
end of the sequence regardless of what transpires during its execution.

\subsection{File Output}
\label{sec:FileOutput}

\subsubsection{Sequence Output Contents}

Smokey writes to a number of files with targeted data.  Their purpose is
described elsewhere,\footnote{See sections \NumNameRef{sec:FolderLayout},
\NumNameRef{sec:LogCollectorFiles}, and \NumNameRef{sec:EarthboundFiles}.} so
this section will concentrate on collating their content description only.

\begin{Definition}

	\item[Smokey.log]  This file is zero-filed on a fresh unit.  Both
	Smokey- and user-generated text is saved to the log file.  Generally,
	everything seen on the console is also saved to file, and vice versa,
	but there are exceptions based based on sequence properties, API calls,
	and individual EFI commands.

	\item[PDCA.plist] This file is zero-filled on a fresh unit.  At the
	start of a sequence, Smokey writes this file with a default result to
	indicate a crash, hang, or power loss; it is later overwritten with the
	actual results of the sequence.  The sequence properties below are used
	in writing this file.\footnote{See section
	\NumNameRef{sec:SmokeyProps}.\label{fn:OutputSmokeyProps}}

	\begin{Descriptive}

		\item[SerialNumberSource] The DUT must be uniquely identified.

	\end{Descriptive}

	\item[.FactoryLogsWaitingToBeCollected] When \filename{PDCA.plist} has
	valid data, this binary file will either be zero length or filled with
	zeros.  Otherwise, the file will either not exist or contain a control
	keyword.

	\item[Earthbound.sig] Security for \filename{PDCA.plist}.  Smokey
	updates this file whenever results are written.

\end{Definition}

\subsubsection{Sequence Output Control}

Some files are individually controlled by sequence
properties.\footref{fn:OutputSmokeyProps}

\begin{Descriptive}

	\item[Smokey.log] File output can be disabled by the \prop{LogBehavior}
	property.

	\item[PDCA.plist] File output can be disabled by the
	\prop{ResultsBehavior} property.

	\item[.FactoryLogsWaitingToBeCollected] File output can be disabled by
	\prop{LogCollectorControl} and \prop{ResultsBehavior}.

	\item[Earthbound.sig] File output can be disabled by the
	\prop{ResultsBehavior} property.

\end{Descriptive}

The contents of output files are checked before a sequence is run in order to
preserve existing data.  In the engineering environments, this behavior can
help prevent data loss due to untrained operators.  However, it can also be
cumbersome if retesting for failure analysis is desired.  For those situations,
it may be helpful to use the \prop{ResultsBehavior} and \prop{LogBehavior}
properties together to disable file access temporarily.

Smokey does not check files that it will not use.  This means, for example,
that \filename{PDCA.plist} need not be present if \prop{ResultsBehavior} is set
to \propval{NoFile}.  Sequences can be configured for limited or no file output
to minimize disk utilization (i.e., fewer preallocated files) or easier
deployment (i.e., smaller number of files).

\subsubsection{Creating Preallocated Sequence Files}

Users are given a choice in how much space to preallocate for sequence output.
Baseline sizes are shown below.  Smaller sizes are allowed as long as the files
are large enough under all known scenarios.

\begin{Descriptive}

	\item[PDCA.plist] 1MB

	\item[Smokey.log] 10MB

\end{Descriptive}

These files can be created from the Mac OS X command shell.  For example, for a
given \param{file} path requiring \param{size} megabytes:

\begin{CommandLine}
dd if=/dev/zero of=~\param{file}~ bs=1m count=~\param{size}~
\end{CommandLine}

The \filename{Earthbound.sig} file can be preallocated using \cmdline{dd} with
an output size of 1KB.

In a pinch, the \filename{.FactoryLogsWaitingToBeCollected} file can be created
similarly.  Its default content must be the word ``SKIP'' followed immediately
by null bytes, padded out to 1KB.

\begin{CommandLine}
echo SKIP > .FactoryLogsWaitingToBeCollected
dd if=/dev/zero of=.FactoryLogsWaitingToBeCollected \
	count=1020 bs=1 seek=4
\end{CommandLine}

\subsubsection{Smokey Control Files}

Smokey uses certain files provided by EFI diags.

\begin{Definition}

	\item[State.txt] Used by the \prop{BehaviorOnAction}
	property.\footnote{See section \NumNameRef{sec:SmokeyProps}.}  Also
	read on every invocation of \cmdline{smokey} to detect
	continuation.\footnote{See section \NumNameRef{sec:SeqStateSaving}.}

\end{Definition}

\subsection{Sequence Output}
\label{sec:SeqOut}

\subsubsection{Run-time Output}

Smokey emits diagnostic and informative data as it runs.  The order is fixed
and the data logged to console and file are basically the same.  However, some
ways of invoking Smokey may omit some sections.

\begin{LogSection}

	\item[Software Build Information] Source code version and binary build
	date.

	\item[Device Identification] MLB and SoC identification numbers.

	\item[Sequence Files] Files nominally used the current sequence.  Some
	files may not be used, pursuant to sequent properties.

	\item[Sequence Properties] Summary of the sequence properties in
	effect.

	\item[Pre-flight Output] Running status as the DUT is prepared for the
	sequence.

	\item[Test Item Trace] A trace as Smokey traverses the sequence.  Each
	line is prefixed with a context information.  EFI diags commands and
	direct script output are interspersed in real time.

	\begin{Definition}

		\item[Timestamp] Shown in square brackets to separate from
		other text on the line.

		\item[Node Number] Smokey-assigned node number for the test
		item.  Replaced with an ellipsis when it is the same as the
		line above.

	\end{Definition}

	\item[Post-Flight Output] The sequence wind-down.  This includes the
	overall sequence result as well as Smokey's attempt to write all
	results to file.

	\item[Error Summary] The ``All Errors'' heading is used to reiterate
	all failures and errors captured during a sequence.  This section is
	omitted when the sequence passes.

\end{LogSection}

\subsubsection{Log File}

All output that Smokey emits to the console is also captured to the sequence's
log file.  Additionally, a time stamp is appended to the log each time it is
opened.  The following example shows the log file of a failed sequence,
including all of the output elements described previously.

\begin{AnnotedLogFile}
~\mp{Log Info}~Opened log at 2012-10-09 12:20:57

~\mp{1. SW Build}~Smokey 1A0529 (changelist 294521)
Built 2012/10/09 02:16:45

~\mp{2. Device ID}~SrNm: CCQHQ06QF4K0
MLB#: C02219500L9F4MQ1
CFG#: DA9/EVT2/00L9//2030/FT1-G2
ECID: 000001D7DC612DC9

~\mp{3. Seq. Files}~Control File: nandfs:\AppleInternal\Diags\Logs\Smokey\Wildfire\N78\Main.plist
Script File:  nandfs:\AppleInternal\Diags\Logs\Smokey\Wildfire\N78\Main.lua
Log File:     nandfs:\AppleInternal\Diags\Logs\Smokey\Wildfire\Smokey.log
Results File: nandfs:\AppleInternal\Diags\Logs\Smokey\Wildfire\PDCA.plist
Control Bit:  Wildfire (0xB4)

~\mp{Log Info}~Finished dumping pre-log buffer

~\mp{4. Seq. Props}~SequenceName:    N78 QT demo
SequenceVersion: 1
BehaviorOnFail:  StopAfterFailedAction
ResultsBehavior: Bookend
LogBehavior:     Full
BrickRequired:   1A

~\mp{5. Pre-flight}~Sequence syntax and sanity check passed

Writing default results
Writing control bit
Writing PDCA plist file

Initializing display
Initializing charger
Device ready

~\mp{6. Test Trace}~Sequence execution...

Day/Time      Node
------------- ----
[09 12:21:04] N001 Repeating 1x
[09 12:21:04] .... 	[1] Periodic tasks
[09 12:21:04] .... 		Detected 1A brick
[09 12:21:04] N002 	[1] Repeating 0x "Battery Protection"
[09 12:21:04] N003 	[1] Repeating 1x "PMU Test"
[09 12:21:04] .... 		[1] PmuTest
[09 12:21:04] .... 			pmureg -r 0 0x00
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) pmureg -r 0 0x00
Register 0x0000 : 0x56
------------------------------------------------------------------------------
[09 12:21:04] .... 			Exit code = 0x00000000
[09 12:21:04] .... 			pmureg -r 0 0xA4
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) pmureg -r 0 0xA4
Register 0x00A4 : 0xB5
------------------------------------------------------------------------------
[09 12:21:04] .... 			Exit code = 0x00000000
[09 12:21:04] .... 			pmustat chipid
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) pmustat chipid
PMU Status test
ChipID: 0x56
------------------------------------------------------------------------------
[09 12:21:05] .... 			Exit code = 0x00000000
[09 12:21:05] N004 	[1] Repeating 2x "Gyro Test"
[09 12:21:05] .... 		[1] GyroTest
[09 12:21:05] .... 			gyro --init
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) gyro --init
Powering on Gyro: OK
Resetting Gyro: OK
Gyro ChipID: ST Micro AP3GDL v3.0.0 part:3
Raw ID: 0xD5
Serial: 0x000000000
Warning: lot/batch numbers are not valid data at this time.
Lot: 0 Batch: 0
OK
------------------------------------------------------------------------------
[09 12:21:05] .... 			Exit code = 0x00000000
[09 12:21:05] .... 			gyro --selftest
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) gyro --selftest
Starting Gyro self-test:
Self Test data:
(3)(-360)DATA: X-diff=363
(1)(362)DATA: Y-diff=361
(0)(-358)DATA: Z-diff=358
OK
------------------------------------------------------------------------------
[09 12:21:06] .... 			Exit code = 0x00000000
[09 12:21:06] .... 			gyro --off
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) gyro --off
Powering down axes: OK
Powering down Gyro: OK
------------------------------------------------------------------------------
[09 12:21:07] .... 			Exit code = 0x00000000
[09 12:21:07] .... 		[2] GyroTest
[09 12:21:07] .... 			gyro --init
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) gyro --init
Powering on Gyro: OK
Resetting Gyro: OK
Gyro ChipID: ST Micro AP3GDL v3.0.0 part:3
Raw ID: 0xD5
Serial: 0x000000000
Warning: lot/batch numbers are not valid data at this time.
Lot: 0 Batch: 0
OK
------------------------------------------------------------------------------
[09 12:21:07] .... 			Exit code = 0x00000000
[09 12:21:07] .... 			gyro --selftest
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) gyro --selftest
Starting Gyro self-test:
Self Test data:
(4)(-360)DATA: X-diff=364
(1)(362)DATA: Y-diff=361
(0)(-358)DATA: Z-diff=358
OK
------------------------------------------------------------------------------
[09 12:21:09] .... 			Exit code = 0x00000000
[09 12:21:09] .... 			gyro --off
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) gyro --off
Powering down axes: OK
Powering down Gyro: OK
------------------------------------------------------------------------------
[09 12:21:09] .... 			Exit code = 0x00000000
[09 12:21:09] N005 	[1] Repeating 1x "WiFi/BT Test"
[09 12:21:09] .... 		[1] WifiBtTest
[09 12:21:09] .... 			device -k WiFi -e power_on
------------------------------------------------------------------------------
~\mp{Diags Command}~:-) device -k WiFi -e power_on
ERROR: Method "power_on" returned status Not Found
device returned Not Found error
------------------------------------------------------------------------------
[09 12:21:09] .... 			Exit code = 0x8000000E
[09 12:21:09] .... 			ActionToExecute failed
[09 12:21:09] .... 		[1] WifiBtHandler
[09 12:21:09] N001 Sequence done

~\mp{7. Post-flight}~Failed

Writing final results
Writing control bit
Writing PDCA plist file

~\mp{8. Error Summary}~All errors:
	SmokeyResults: failed action WifiBtTest at node 5 iteration 1/1: EfiCommand: command had errors: device -k WiFi -e power_on
	SmokeyCore: stopping after failed action
\end{AnnotedLogFile}

\subsubsection{Sequence Dump}

\begin{LogExcerpt}
:-) smokey Wildfire --sequence
~\elide~
Test Sequence

Day/Time      Node
------------- ----
[09 11:13:17] N001 Repeat 1x
[09 11:13:17] N002      Repeat 0x "Battery Protection"
[09 11:13:17] ....              BatteryProtection
[09 11:13:17] N003      Repeat 1x "PMU Test"
[09 11:13:17] ....              PmuTest
[09 11:13:17] N004      Repeat 2x "Gyro Test"
[09 11:13:17] ....              GyroTest
[09 11:13:17] N005      Repeat 1x "WiFi/BT Test" --> WifiBtHandler
[09 11:13:17] ....              WifiBtTest
\end{LogExcerpt}

As a diagnostic and informative feature, Smokey can print the test order of a
sequence without doing anything else.  The \cmdline{--sequence} command line
option will print the test order very similar to the way that Smokey executes
it with \cmdline{--run}.

\begin{Descriptive}

	\item[Exhaustive Listing] All test items are included, even those with
	\prop{NumberOfTimesToRun} set to zero.

	\item[Explicit Properties] The properties \prop{TestName} and
	\prop{NumberOfTimesToRun} are shown.  \prop{FailScript} is on same line
	as \prop{NumberOfTimesToRun}, prefixed with an arrow.

	\item[Actions] \prop{ActionToExecute} is shown on its own line.

\end{Descriptive}

\subsubsection{Sequence Summary}

\begin{LogExcerpt}
:-) smokey Wildfire --summary
~\elide~
Test Sequence Summary

Day/Time      Node
------------- ----
[09 11:13:17] N001 Repeat 1x
[09 11:13:17] N003      PmuTest
[09 11:13:17] N004      Repeat 2x
[09 11:13:17] ....              GyroTest
[09 11:13:17] N005      WifiBtTest --> WifiBtHandler
\end{LogExcerpt}

The \cmdline{--summary} command line option is similar to the
\cmdline{--sequence} option, but potentially a lot more concise.

\begin{Descriptive}

	\item[Concise Listing] No test items with zero iterations.  Children of
	those test items are also omitted.

	\item[Abbreviated Properties] Test items with only one iteration do not
	have a separate output line indicating showing
	\prop{NumberOfTimesToRun}.  \prop{TestName} is omitted on all test
	items.  \prop{FailScript} is on the same line as \prop{ActionToExecute}
	if the line with \prop{NumberOfTimesToRun} is omitted.

\end{Descriptive}

\subsubsection{Sequence Dependencies}

\begin{LogExcerpt}
:-) smokey Wildfire --dependencies
~\elide~
Test Sequence Load-Time External Code Dependencies

Require: Battery             (...\Wildfire\N51\Battery.lua)
Require: DiagsParser.11A     (...\Shared\DiagsParser\11A\init.lua)
Require: FATP                (...\Wildfire\N51\FATP.lua)
Require: Leakage             (...\Wildfire\N51\Leakage.lua)
Require: MesaProvisioned.11A (...\Shared\MesaProvisioned\11A\init.lua)
Require: Syscfg.11A          (...\Shared\Syscfg\11A\init.lua)
Require: Syscfg.11A.syscfg   (...\Shared\Syscfg\11A\syscfg.lua)
Source File: nandfs:\AppleInternal\Diags\Logs\Smokey\Wildfire\N51\Main.lua
Source File: nandfs:\AppleInternal\Diags\Logs\Smokey\measure_vbat_dcr\N51\Main.lua
\end{LogExcerpt}

The \cmdline{--dependencies} option shows the modules and Lua files that are
loaded through standard means, as well as the sequence code itself.

\begin{Descriptive}

	\item[Modules] Top-level modules and consequential submodules loaded
	with the \func{require} function.  The module name and file location
	are both shown.

	\item[Sequence Code File] The main Lua file for the sequence code.

	\item[Lua Files] Individual source files loaded with \func{loadfile} or
	\func{dofile}.

\end{Descriptive}

\subsection{Screen Output}

\begin{StatusScreenTable}
	\NestedImage{ScreenConnectToBrick.pdf} &
	\NestedImage{ScreenRunning-Cinnamon.pdf} &
	\NestedImage{ScreenPass.pdf} &
	\NestedImage{ScreenFail.pdf} \\
\end{StatusScreenTable}

If the DUT has a display module available, Smokey provides visual feedback on
the sequence's execution using modal screens.  Each has a distinct color or
design to make it easy to identify state at a glance.

\begin{Descriptive}

	\item[Connect to Brick] Sequence is running, but halted while DUT is
	waiting for an external charger.  Background is bright yellow and
	instructions in black text.

	\item[Running Status] DUT is running an action.  A logo is shown in the
	background.  The sequence name, progress, current test, and power info
	are shown in white text over a black background.

	\item[Pass] Sequence is complete and successful.  Background is bright
	green.

	\item[Fail] Sequence is complete but failed.  Background is bright red.

\end{Descriptive}

\subsection{State Control}

Smokey will generally manage its state without need for outside intervention.
However, commands are available to clear the state and get the DUT back to
normal.  These are useful, for example, for triaging a problem or interrupting
a sequence while the DUT is rebooting.

To understand why these commands work, please be sure to read section
\NumNameRef{sec:SeqStateSaving} before proceeding.

\subsubsection{Clearing State}

In order to run a new sequence, or restart a previous sequence, the previously
saved state must be cleared.  See the description of command line options in
section \NumNameRef{sec:CmdArgs} for the exact syntax to clear the current
Smokey state.

Smokey only supports one state to be shared amongst all sequences.
Effectively, clearing one saved state will clear them for all sequences.

\subsubsection{Clearing Autostart}
\label{sec:ClearingAutostart}

Aborting or cancelling an autostart of Smokey requires that the DUT be
intercepted before it boots into EFI diags, then disabling the autostart
configuration.  This will allow EFI diags to boot to the interactive command
line instead.

The work boils down to either catching the DUT before it reboots or
interrupting iBoot before it loads EFI diags.  The particular details of doing
so this won't be covered here, but any method that allows safe access to the
respective command line should work.

Once control is gained over the DUT, the following NVRAM variables can be
changed:

\begin{Descriptive}

	\item[boot-args] The \nvarg{smokey} argument must be removed.

	\item[boot-command] This will likely be set to \nvarg{diags} during
	autostart. If the goal is not to boot into EFI diags, then
	\nvram{boot-command} needs to be set accordingly.  Otherwise, the value
	can be left untouched.

	\item[auto-boot] Like \nvram{boot-command}, this can usually be left
	alone, but can be changed depending on the situation.  Smokey doesn't
	modify this variable.

\end{Descriptive}

Additional work beyond the scope of this document may be required if the DUT's
particular build of EFI diags is configured to autostart software other than
Smokey.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Using Smokey Simulator}

Smokey Simulator is a companion tool, built from the same source code as
Smokey, for executing and validating sequences from the command line.  Whereas
the \cmdline{smokey} command in EFI diags runs on a DUT, the simulator runs on
a host and provides a comparable level of functionality for the Mac OS
environment.  Additionally, it provides the capability to delegate EFI diags
commands to a linked DUT.

\subsection{Differences from Smokey}

Internally, the simulator is a port of Smokey, so they are largely identical.
This means the simulator can be used for validation and syntax checking of test
sequences, and, furthermore, to execute the sequences themselves.

Differences arise during interactions with the run-time environment.
Deviations occur because Smokey Simulator runs on a host and has the point of
view of a Mac OS application, whereas Smokey runs on a DUT and has the
perspective of an EFI diags application, so their views of the world are
different.

\begin{Descriptive}

	\item[File Paths] Both Smokey and Smokey Simulator pass along file
	paths to the run-time environment verbatim, so they are identical in
	this regard.  However, because a DUT will require EFI-style paths and a
	host will require UNIX-style paths, tests will need to either
	special-case the difference themselves or use Smokey API functions like
	\func{FindSequenceFile}\footnote{See section
	\NumNameRef{sec:SmokeyApi}.\label{fn:DiffApi}} to factor out that
	logic.

	\item[Input Files] Sequences and shared modules are treated as being in
	the current working directory by default.  Relative and absolute path
	overrides are supported for input files that are spread across the host
	filesystem.

	\item[Output Files] File output is written to the input directories
	configured at the start of the simulation. Contrast this to Smokey on a
	DUT, where input locations are fixed, so output files are therefore at
	fixed locations as well.

	\item[Ancillary Files] Smokey uses certain external files that are laid
	down during a restore.  Smokey Simulator likewise requires these files
	to pre-exist and also creates files of its own to emulate DUT
	processes.

	\begin{Descriptive}

		\item[State.txt] Prerequisite.  File must exist, but can be
		empty.

		\item[ControlBit.txt] Output file.  Created at run time.

	\end{Descriptive}

	\item[Control Bits] Since Mac OS does not have control bits in the same
	sense as Apple mobile products, reads and writes are faked.  Control
	bits always read \nvarg{Untested}.  Writes are recorded to the
	ancillary output file \filename{ControlBit.txt} in text format.

	\item[NVRAM] Non-volatile system variables are not supported.  Any
	Smokey actions in the simulator that require the \nvarg{smokey}
	argument shall behave as if it were not set.

	\item[Platform Identification] Smokey Simulator promulgates the
	fictitious Z99 platform to test sequences.  Command line settings can
	be used to override this identity piecemeal, as can link mode.  Lua
	code can call the \func{PlatformInfo}\footref{fn:DiffApi} API function
	to detect whether the sequence being executed by Smokey Simulator.

	\item[Autostart] Not supported.

	\item[External Commands] In the simulator, the Smokey API function
	\func{Shell} ultimately calls the C library function \func{system}.  As
	a result, external commands are routed through the host system's shell.
	This behavior can be used, to a limited degree, for targeted validation
	if the inputs and outputs of EFI diags commands can be emulated by mock
	command scripts.  When live execution of EFI commands is required, link
	mode should be used.

\end{Descriptive}

\subsection{Emulating the DUT Work Environment}

Smokey assumes fixed locations\footnote{See section \NumNameRef{sec:FileOrg}.}
on the DUT for storing test sequences, modules, and ancillary files.  Smokey
Simulator does not make the same assumption and must consider the layout of the
host filesystem.  We can reconcile the two by imagining that Smokey uses its
home folder as the current working directory.  Thus, the sequences names in a
\cmdline{smokey} command line can be seen as relative paths to directories.
Substituting the \cmdline{smokey} command name with \cmdline{SmokeySimulator}
results in a simulator command line that mimics its EFI counterpart.  This is
the recommended way of calling with the simulator because it minimizes command
line arguments and makes switching between environments easier.

Emulating the DUT work environment requires a directory configured with the
proper files and folders.  One way to get such a directory is to use the
\filename{Smokey} directory from a full EFI diags root, restore bundle, or the
EFI factory scripts repositories\footnote{Formerly Blaze, but presently
FactoryLLScriptsCommon or FactoryLLScriptsPlatforms.}.  Another way is to use
the simulator release archive, which also includes workflow helper files.
Lastly, a directory can be created from scratch, as outlined below.  Once the
directory is set up, use the shell \cmdline{cd} command to change the working
directory before invoking Smokey Simulator.

Manually crafting a directory tree for Smokey Simulator involves creating
ancillary files and setting up the corequisites of the test sequence of
interest.  There is currently only one required ancillary file,
\filename{State.txt}, so most effort will center around the auxiliary files and
modules of the sequence.

In the very minimal case, three files must be created, as shown in figure
\ref{fig:SimWorkingDirs}.  Advanced development environments may have multiple
sequences in the working directory, as well as a \filename{Shared} directory
for shared modules.  In both scenarios, it may be helpful to either copy or
create a symbolic link to the simulator binary.

\begin{figure}[h]

	\begin{SideBySideGrid}

		\HeadingRow{Minimal Working Directory}{Working Directory}

	\NextRow

		\begin{NestedDirectoryTree}
		\Root{Smokey}{
			\File{State.txt}
			\Directory{Sequence}{
				\File{Main.lua}
				\File{Main.plist}
			}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		\begin{NestedDirectoryTree}
		\Root{Smokey}{
			\File{SmokeySimulator}
			\File{State.txt}
			\ClosedDirectory{SequenceOne}
			\ClosedDirectory{SequenceTwo}
			\ClosedDirectory{SequenceThree}
			\Directory{Shared}{
				\ClosedDirectory{ModuleA}
				\ClosedDirectory{ModuleB}
				\ClosedDirectory{ModuleC}
			}
		}
		\end{NestedDirectoryTree}

	\LastRow
	\end{SideBySideGrid}

	\caption{Examples of Simulator Working Directories}
	\label{fig:SimWorkingDirs}

\end{figure}

Note that Smokey Simulator can still run if the above layout is not possible.
Refer to the command line reference for the arguments required to tell the
simulator where to find requisite files.

\subsection{Link Mode}

Link mode is a method of delegating the execution of EFI diags commands to a
tethered DUT.  Rather than merely simulating a test sequence via dry run or
mock command scripts, it is possible to execute a sequence on a host very close
to the way it would on a DUT.  Additionally, link mode shortens edit-run-debug
cycles by skirting the need to transfer files back and forth, and optimizing
the number of DUT reboots.

\subsubsection{System Requirements}

The simulator link is an RPC mechanism built upon a UART channel between host
and DUT.  Several pieces of hardware and software are required on both sides to
make it work.

\begin{itemize}

	\item Host-side requirements

	\begin{itemize}

		\item Recent build of Smokey Simulator

		\item Bacon, Kong, or similar cable for UART communication

		\item \cmdline{usbterm} application (optional)

	\end{itemize}

	\item DUT-side requirements

	\begin{itemize}

		\item EFI diags with RPC-enabled version of Smokey

		\item iBoot-based firmware (optional)

	\end{itemize}

\end{itemize}

All recent versions of EFI diags satisfy the RPC requirement.  If a manual
check is required, run the following command on the DUT:

\begin{CommandLine}
smokey --rpc
\end{CommandLine}

This will produce an \cmdline{RPC>} prompt if the diags image is compatible.
Otherwise, it will complain about unsupported command line arguments.  To exit
RPC mode and return to the EFI command shell, press \KeyCapsCtrlD.

Likewise, the simulator can be checked by either using the \cmdline{--link}
option or looking at the \cmdline{--help} output.

Both \cmdline{usbterm} and iBoot are required only when using Smokey Simulator
to boot the DUT into EFI diags.  The simulator option \cmdline{--diags} will
require both iBoot and \cmdline{usbterm}.  iBoot alone is sufficient when
booting the diags image already in the DUT's filesystem.

\subsubsection{Setting Up the Host and DUT}
\label{sec:Setup}

Before the simulator link can be used, the DUT must be configured and the host
environment must be set up.

\begin{itemize}

	\item Host-side configuration

	\begin{itemize}

		\item All other software using the UART link, including
		\cmdline{nanokdp}, must be terminated

	\end{itemize}

	\item DUT-side configuration

	\begin{itemize}

		\item Disable \nvram{auto-boot} in iBoot (optional)

		\item Root the desired EFI diags image onto the DUT (optional)

		\item Run \cmdline{usbterm} in the background (optional)

		\item DUT must be in either iBoot or EFI when starting the link

	\end{itemize}

\end{itemize}

All of the optional DUT settings center around boot behavior.  It is
recommended that \nvram{auto-boot} be disabled at the least.  However,
engineering efforts may require loading custom software, so Smokey Simulator
has allowances for getting the DUT into link mode.  The following list will
document the scenarios and settings involved, but won't delve into the nuances
of all the possible permutations of configuration settings.

\begin{itemize}

	\item If the DUT will always be in EFI at the start of tethering and
	the test sequence does not reboot the DUT, all the optional boot
	settings may be omitted.  When reboots are involved, the remaining
	scenarios must be considered.

	\item If the EFI diags image on the DUT is sufficient, tethering can
	start with the DUT in either diags or iBoot.  Reboots of the DUT during
	the test sequence will require that \nvram{auto-boot} be disabled;
	alternatively, \nvram{auto-boot} can be left enabled if
	\nvram{boot-command} is set to \nvarg{diags}.

	\item If a custom EFI diags is required and engineering efforts allow
	the DUT to be modified, it sometimes saves time to root diags onto the
	device.  Doing so will obviate \cmdline{usbterm}.  The DUT still needs
	a way to get into EFI diags, so it must either be put into diags
	manually or left in iBoot for Smokey Simulator to handle.  If reboots
	are expected, see the notes above about \nvram{auto-boot} and
	\nvram{boot-command}.

	\item If a custom EFI diags is required and the DUT's filesystem must
	be left intact, Smokey Simulator can load the diags image dynamically.
	This requires \cmdline{usbterm} to be running in the background.
	Smokey Simulator will need access to iBoot, so the DUT must be in
	recovery mode at the start of tethering.  If reboots are expected,
	\nvram{auto-boot} must be disabled so that the simulator has a chance
	to re-load the diags image.

\end{itemize}

\subsubsection{Disabling Auto-Boot in iBoot}

The exact way to disable \nvram{auto-boot} will vary by environment.  To
disable from iOS: 

\begin{CommandLine}
nvram auto-boot=false
\end{CommandLine}

To disable \nvram{auto-boot} from iBoot: 

\begin{CommandLine}
setenv auto-boot false
saveenv
\end{CommandLine}

To disable \nvram{auto-boot} from EFI:

\begin{CommandLine}
nvram --set auto-boot false
nvram --save
\end{CommandLine}

\subsubsection{Choosing a Link Device}
\label{sec:LinkDevice}

Link mode requires the use of a communications channel between the host and DUT
for remote procedure calls.  The current implementation is built on top of UART
in order to have wide compatibility with EFI, iBoot, and other environments.

Those using EFI diags are already familiar with the serial port on the DUT dock
connector.  This will typically be the same device used for the simulator link
because it is common to all environments on Darwin platforms.  In circumstances
where the DUT will not leave EFI diags, it is possible to use an alternate UART
such as USB CDC, which is much faster than standard serial devices.

Smokey Simulator needs the UNIX path to a character device representing the
UART connection to the DUT.  This is typically a file under the \dirname{/dev}
directory with the prefix \filename{cu.} followed by the device type and a
unique identifier.  The example below shows such a device provided by the Kong
hardware debugger.

\begin{Setting}
/dev/cu.kong-20063F
\end{Setting}

Alternatively, here is an example of a UART device exported by the EFI diags
USB CDC emulation driver.

\begin{Setting}
/dev/cu.usbmodemfd1411
\end{Setting}

Users of the \cmdline{nanokdp} command line option \cmdline{-d} can use the
same argument for the Smokey Simulator \cmdline{--link} option.  Other users of
\cmdline{nanokdp} can find the character device of an open session in the
escape menu.

The simulator will typically require exclusive access to the UART device.
Attempting to share the link device may cause lost characters or indefinite
stalls for data.

\subsubsection{Using Link Mode}

The main design goal of link mode is to closely emulate the execution of a test
sequence as it would behave on a DUT.  This is accomplished by remotely
executing a subset of the Smokey API on the DUT.  Invocations of the functions
below will actively use the DUT link.

\begin{Descriptive}

	\item[Shell] EFI command lines are executed remotely.  Output is
	captured and sent back to the host.

\end{Descriptive}

Additionally, the following features are proxied to the DUT.

\begin{Descriptive}

	\item[Device Information] Hardware information such as (but not limited
	to) platform name, serial number, and board ID are read from the DUT
	directly.  Software build information such as the EFI build version is
	also queried.

	\item[Charger] Brick identification and battery charging will happen as
	if Smokey were running on the DUT.

	\item[Status Screen] Smokey's sequencer status screen is displayed on
	the DUT's screen and reflects the host's progress as Smokey Simulator
	runs.

\end{Descriptive}

\subsubsection{Quitting a Link}

Smokey Simulator will automatically terminate link mode and shut down the RPC
tunnel when it exits cleanly.  This will typically leave the DUT at the EFI
command line.

The simulator will also terminate link mode if it detects a reboot or shutdown.
The DUT's ultimate state will depend on the commands being executed at the
time.

If the simulator gets hung for some reason, it can be interrupted with
\KeyCapsCtrlC{}.  However, doing so can leave the DUT in the middle of the RPC
tunnel.  To clean up the DUT, connect to it using \cmdline{nanokdp} and press
\KeyCapsCtrlD{} to quit.  It may be necessary to press \KeyCapsEnter{} a few
times to get its attention before doing this.

\subsubsection{Continuing a Link}

Smokey Simulator will quietly and immediately exit if it detects that the DUT
has shutdown or rebooted.  This mimics the behavior of the DUT as seen with the
\cmdline{smokey} command.  When this happens, and \prop{BehaviorOnAction} was
set to \propval{SaveState}, Smokey Simulator can continue running the sequence
where it left off, with the sequence and simulator settings that were in effect
at that time, including link mode, without reiterating the previous command
line options.  To do this, simply use the \cmdline{--run} argument by itself.

\begin{CommandLine}
SmokeySimulator --run
\end{CommandLine}

If this is not desired, use the following command---by itself---to make Smokey
Simulator forget the previously saved state.

\begin{CommandLine}
SmokeySimulator --clearstate
\end{CommandLine}

\subsubsection{Loading an EFI Diags Image}

In link mode, Smokey Simulator will automatically boot EFI diags if it detects
that the DUT is in recovery mode.  By default, the diags image on the DUT will
be used, but a custom image can be specified at the command line\footnote{See
\NumNameRef{sec:SimCmdArgs}.} for advanced development and debug scenarios.

See \NameRef{sec:Setup} for configuration requirements.  Generally,
\nvram{auto-boot} should be disabled and the DUT should be at the iBoot prompt.

Additionally, the \cmdline{usbterm} program is required in the background.  If
more than one device is connected to the host, the command line option
\cmdline{-locationid} can be used to specify the DUT that Smokey Simulator will
be controlling.

Once the link is up and running, the start-up banner will display the version
number of the EFI diags image on the DUT, underneath the simulator copyright
and version lines.  For example:

\begin{TerminalOutput}
Smokey Simulator - Copyright (C) 2012-2014 Apple Inc
Simulator 1A0035 (changelist 343409) 2014/02/24 15:10:09
N51 GreatDane 13C0586ae (changelist 42055) 2013/08/03 18:24:18
\end{TerminalOutput}

The above shows a DUT based on the N51 platform running EFI diags version
13C0586ae, as well as the date and time of the build.

\subsection{Smokey Simulator Command Line Arguments}
\label{sec:SimCmdArgs}

Smokey Simulator builds upon the command line arguments of Smokey.  In addition
to the conventions and usage described in section \ref{sec:CmdArgs}, several
simulator-specific arguments are available.

In the descriptions that follow, \cmdline{SmokeySimulator} should be
substituted with the correct path to the simulator binary.

\subsubsection{Specifying a Sequence}

\begin{CommandLine}
SmokeySimulator ~\param{Directory}~
\end{CommandLine}

Sequence names are treated as directory paths.  \param{Directory} can be a bare
name---unadorned with path separators---if it is in the current directory.
Relative and absolute paths are also supported.  Trailing slashes are tolerated
in order to accommodate shell tab completion.

\subsubsection{Specifying a Shared Directory}

\begin{CommandLine}
SmokeySimulator ... --shared ~\param{SharedDirectory}~
\end{CommandLine}

Smokey searches for shared code in a predefined directory.  In the simulator,
the default path is \filename{Shared}, which is presumed to be in the current
directory, but can be overridden from the command line.  The first use of
\cmdline{--shared} replaces the built-in default with \param{SharedDirectory}.
Subsequent uses append additional paths to the search list.

\subsubsection{Booting an EFI Diags Image}

\begin{CommandLine}
SmokeySimulator ... --diags ~\param{ImagePath}~
\end{CommandLine}

When link mode is enabled, load a specific EFI diags image if the DUT is in
recovery mode (i.e., at the iBoot prompt).  If the DUT is already in diags, the
currently running version will be used instead.

The file \param{ImagePath} must be either \filename{.img3} or \filename{.img4}
format, as appropriate for the DUT.

While the image is loading, \cmdline{usbterm} must be running in the background
to facilitate the transfer.  Additionally, Apple Connect may be required for
security reasons.

\subsubsection{Override Platform Identity}

\begin{CommandLine}
SmokeySimulator ... --platform ~\param{PlatformName}~
\end{CommandLine}

\begin{CommandLine}
SmokeySimulator ... --model ~\param{ModelName}~
\end{CommandLine}

\begin{CommandLine}
SmokeySimulator ... --boardid ~\param{IdNum}~
\end{CommandLine}

\begin{CommandLine}
SmokeySimulator ... --boardrevision ~\param{RevNum}~
\end{CommandLine}

Override the simulator's and the test sequence's default view of the platform
under test.  These options affect several functional areas.

Smokey uses the platform name when finding sequence and module files.  The
option \cmdline{--platform} influences this behavior and can be used to alter
the normal processing of a test sequence.

The \func{PlatformInfo}\footnote{See section \NumNameRef{sec:SmokeyApi}.} API
function will relay the \param{PlatformName}, \param{ModelName}, \param{IdNum},
and \param{RevNum} values to test code.

\subsubsection{Enabling DUT Link}

\begin{CommandLine}
SmokeySimulator ... --link ~\param{UartPath}~
\end{CommandLine}

Enable link mode.  The argument \param{UartPath} must point to a UART-like
character device in the filesystem.\footnote{See section
\NumNameRef{sec:LinkDevice}.}

No other program shall use the device at \param{UartPath} concurrently with
Smokey Simulator.  The most common cause for failure to enable link mode is a
background task using \param{UartPath} while the simulator accesses it.

This option overrides all of the platform identity options.

\subsubsection{Logging DUT Link}

\begin{CommandLine}
SmokeySimulator ... --rxlog ~\param{LogPath}~
\end{CommandLine}

When link mode is active, save raw data received from the DUT to
\param{LogPath}.  This option has no effect outside of link mode.  

When a new link is established, the file \param{LogPath} is overwritten.  Data
is appended to \param{LogPath} when Smokey Simulator reuses a link from a
previous session, such as when it continues from a saved state.

\subsection{Distribution}

The simulator is distributed via SDK and standalone archive.  The SDK release
makes the latest Smokey Simulator build readily available to developers who
have access to daily iOS builds.  Standalone releases are done regularly and
include example files.

Simulator releases are built independently of each other, so feature sets are
not in lock step, but they will generally have parity.  Neither are explicitly
synchronized with builds of Smokey for EFI diags.

\subsubsection{Smokey Simulator SDK Binary}

The Smokey Simulator binary is distributed as part of the iOS UI and NonUI
portion of the Apple-internal SDKs.  When Xcode command line tools are
available, the simulator binary can be invoked by name, as shown below.  Any
arguments past the simulator command name are passed directly to the
simulator.\footnote{Refer to section \NumNameRef{sec:CmdArgs} for command line
tool conventions.}

\begin{CommandLine}
xcrun --sdk iphoneos SmokeySimulator ...
\end{CommandLine}

When the overhead of calling \cmdline{xcrun} must be minimized, it is possible
to print the absolute path to \cmdline{SmokeySimulator} so that it may be
stored in a shell variable, alias, or symbolic link.

\begin{CommandLine}
xcrun --sdk iphoneos -f SmokeySimulator
\end{CommandLine}

\subsubsection{Release Archive}

\paragraph{Archive Contents}

The Smokey Simulator archive is distributed as a \filename{.zip} file on the
Smokey wiki.\footnote{See section \NumNameRef{sec:AppleLinks}.}  In addition to
the simulator binary, the archive also includes ancillary files, a
\filename{Makefile}, sample sequences, and a directory for shared modules.  A
sample directory listing is shown in figure \ref{fig:SimulatorArchive}.

\begin{figure}[h]

	\begin{CenteredDirectoryTree}
	\DiskRoot{SmokeySimulator.zip}{
		\File{Makefile}
		\File{SmokeySimulator}
		\File{State.txt}
		\ClosedDirectory{ComplexModuleDemo}
	%	\Directory{ComplexModuleDemo}{
	%		\File{Main.lua}
	%		\File{Main.plist}
	%	}
		\Directory{HelloWorld}{
			\File{.FactoryLogsWaitingToBeCollected}
			\File{Main.lua}
			\File{Main.plist}
			\File{PDCA.plist}
			\File{Smokey.log}
		}
		\ClosedDirectory{StIves}
	%	\Directory{StIves}{
	%		\File{.FactoryLogsWaitingToBeCollected}
	%		\File{Main.lua}
	%		\File{Main.plist}
	%		\File{PDCA.plist}
	%		\File{Smokey.log}
	%	}
		\Directory{Shared}{
			\Directory{ComplexPlatformModule}{
				\Directory{Latest}{
					\ClosedDirectory{Platform}
	%				\Directory{Platform}{
	%					\File{N51.lua}
	%				}
					\File{Common.lua}
					\File{Default.lua}
					\File{Package.lua}
					\File{PlatformSpecific.lua}
					\File{init.lua}
				}
			}
		}
	}
	\end{CenteredDirectoryTree}

	\caption{Simulator Release Archive}
	\label{fig:SimulatorArchive}

\end{figure}

\paragraph{Using the Simulator Makefile}

The included \filename{Makefile} has rules for basic interaction with Smokey
files.

\begin{CommandLine}
make files
\end{CommandLine}

The \cmdline{files} target will regenerate a blank \filename{State.txt} file,
or create one if it does not exist.  The
\filename{.FactoryLogsWaitingToBeCollected}, \filename{PDCA.plist}, and
\filename{Smokey.log} files for the bundled sequences will be overwritten with
fresh copies.

\begin{CommandLine}
make clean
\end{CommandLine}

The \cmdline{clean} target will erase any ancillary output files that the
simulator creates during its execution.

\begin{comment}

\subsection{Working with Source Code}

% The text below is obviated by the "Emulating the DUT Work Environment"
% section.  Additionally, the migration to FactoryLLScriptsCommon and
% FactoryLLScriptsPlatforms obviates any mention of Blaze.

The simulator link feature can make it easy to work with filesystem roots.  One
example of this is the Smokey directory in Blaze:  the recent reorganization
closely mimics the layout on the DUT.  To use Blaze with the simulator, one of
the following is required:

- Sequence is platform agnostic and files are stored under
	Blaze/Smokey/SEQUENCE/Main.plist
	Blaze/Smokey/SEQUENCE/Main.lua
- Sequence is platform-specific and files are stored under
	Blaze/Smokey/SEQUENCE/PLATFORM/Main.plist
	Blaze/Smokey/SEQUENCE/PLATFORM/Main.lua
- Sequence is platform-specific and files are stored under
	Blaze/Smokey/SEQUENCE/PLATFORM.plist
	Blaze/Smokey/SEQUENCE/PLATFORM.lua

where SEQUENCE is the specific sequence name (e.g. Wildfire) and PLATFORM is
the platform name according to EFI (e.g. N78, K93, N41).  For platform-specific
sequences, the simulator will detect the DUT platform and choose the
corresponding files.

Blaze is intended only for source code, but Smokey expects output files (e.g.
Smokey.log and PDCA.plist) to exist beforehand.  To aid in generating these
files, a Makefile has been checked into Blaze as Blaze/Smokey/Makefile.  To use
it, go to the Blaze/Smokey directory and run the command

	make files

Conversely, to remove the output files, run the command

	make clean

Using the simulator will require the binary be accessible from the Blaze/Smokey
directory.  This can be done either by copying the binary into Blaze/Smokey or
using the full path when calling the binary.

Once the files are set up, simulator usage is fairly straightforward:

1. "cd" into the Smokey directory
	cd /path/to/Blaze/Smokey
2. Run Smokey
	SmokeySimulator --link /path/to/uart [other arguments here]

Note that, at this point, the sequence name given at the command line will
actually be a directory name relative to the current working directory.  This
is a convenient way of emulating the command line used on the DUT.  Also note
that the default search path for shared Smokey files maps to
Blaze/Smokey/Shared under these circumstances, so the --shared argument is not
required.

To re-run a sequence that has already generated output, you can use "make
files" zero the output files.

\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Developing Smokey Sequences}

\subsection{Smokey Properties}
\label{sec:SmokeyProps}

The Smokey sequence schema is comprised of key-value pairs defining tests, flow
control, and overall behavior.  Some properties are nested, meaning that they
can encapsulate other properties.  Others are cascading, meaning that their
settings affect nested properties.  The following sections will describe the
plist types, legal values, placement, and purpose of sequence properties.
Refer to figure \ref{fig:AllProps} for an illustration of all properties and
their use.

\begin{figure}[p]
\begin{FullWidth}

	\begin{CenteredPropertyList}[Comment]{20em}
	\Root{Main.plist}{
		% Mandatory Control Properties
		\String{SequenceName}{Required}
		\String{SequenceVersion}{Required}
		\Number{SchemaFormat}{Required}
		\String{BrickRequired}{Required}
		% Optional Control Properties
		\String{LogBehavior}{}
		\String{ResultsBehavior}{}
		\String{SerialNumberSource}{}
		\String{LogCollectorControl}{}
		\String{ControlBitAccess}{}
		% Test Root Properties
		\String{FailScript}{}
		\Number{NumberOfTimesToRun}{Required}
		\String{BehaviorOnFail}{Required}
		\Dictionary{Arguments}{
			\String{\param{ArgName} ...}{Lua expression}
		}
		% Test Item Properties
		\ArrayExtra{Tests}{Required}{
			\Dictionary{Item ...}{
				\String{TestName}{}
				\String{FailScript}{}
				\Number{NumberOfTimesToRun}{Required}
				\String{BehaviorOnAction}{}
				\String{BehaviorOnFail}{}
				\String{ThisBehaviorOnFail}{}
				\Dictionary{Arguments}{
					\String{\param{ArgName} ...}{Lua expression}
				}
				\String{ActionToExecute}{Required}
			}
			\Dictionary{Item ...}{
				\String{TestName}{}
				\String{FailScript}{}
				\Number{NumberOfTimesToRun}{Required}
				\String{BehaviorOnFail}{}
				\String{ThisBehaviorOnFail}{}
				\ArrayExtra{Tests}{Required}{
					\Dictionary{Item 0}{}
					\Dictionary{Item 1}{}
					\Dictionary{Item ...}{}
				}
			}
		}
	}
	\Annotate{1}{4}{Mandatory}
	\Divider{4}
	\Annotate{5}{9}{Optional}
	\Divider{9}
	\Annotate{10}{15}{Test Root}
	\Divider{15}
	\Annotate{16}{32}{Test Items}
	\Divider{32}
	\Annotate{33}{35}{Nested Tests}
	\end{CenteredPropertyList}

	\caption{All Sequence Properties}
	\label{fig:AllProps}

\end{FullWidth}
\end{figure}

\subsubsection{Mandatory Control Properties}

\begin{PropertyTable}
	\prop{SequenceName}    & String & Required \\
	\prop{SequenceVersion} & String & Required \\
	\prop{SchemaFormat}    & Number & Required \\
	\prop{BrickRequired}   & String & Required \\
\end{PropertyTable}

These properties define the basic parameters that Smokey uses when processing a
sequence.  They must be at the root of the plist.  All values are required.

\begin{Property}

	\item[SequenceName] Text string describing the sequence.  This can be
	more elaborate than the sequence directory name.

	\item[SequenceVersion] User-defined identifier to track changes and
	revisions.  For example, this could be a sequential number, or a date
	format like YYYYMMDD, where the letters are replaced with digits for
	the calendar year, month, and day.

	\item[SchemaFormat] Currently must be set to 1.

	\item[BrickRequired] Apple charger required to start or continue the
	sequence.

	\begin{Definition}

		\item[None] No charger required and no checks performed.

		\item[Any] Charger will be checked but any known external
		charger will be accepted.

		\item[500mA] Sufficiently powered USB hub.

		\item[1A] B1 or equivalent.

		\item[2.1A] B9 or equivalent.

		\item[2.4A] B45 or equivalent.

	\end{Definition}

\end{Property}

\subsubsection{Optional Control Properties}

\begin{PropertyTableRelated}
	\prop{LogBehavior}         & String & Optional (\propval{Full})      &                        \\
	\prop{ResultsBehavior}     & String & Optional (\propval{Bookend})   &                        \\
	\prop{SerialNumberSource}  & String & Optional (\propval{SrNm})      & \prop{ResultsBehavior} \\
	\prop{LogCollectorControl} & String & Optional (\propval{Semaphore}) & \prop{ResultsBehavior} \\
	\prop{ControlBitAccess}    & String & Optional (\propval{Default})   &                        \\
\end{PropertyTableRelated}

These properties fine tune Smokey behavior.  Like the mandatory control
properties, these must be at the root of the plist.

\begin{Property}

	\item[LogBehavior] Control Smokey-generated output during a test
	sequence.  Any output before Smokey can determine the effective value
	of this property will be buffered.  Smokey may override this property's
	value and enable console output if it must abort execution.

	\begin{Definition}

		\item[Full] Enable writing to both console and the log file.
		This is the default when \prop{LogBehavior} is not defined.

		\item[ConsoleOnly] Disable writing to the log file.

		\item[FileOnly] Disable writing to console.

		\item[NoLogging] Disable both console and log file output.

	\end{Definition}

	\item[ResultsBehavior] Select the frequency of results updates.  This
	property affects all results stored in the filesystem, including
	\filename{PDCA.plist}, LogCollector- and Earthbound-related files, and
	signatures.

	\begin{Definition}

		\item[Bookend] Write results to file at the start and finish of
		the sequence.  This is the default when \prop{ResultsBehavior}
		is not defined.

		\item[AlwaysWrite] In addition to \propval{Bookend} behavior,
		results are updated as soon as new attributes or data are
		reported,\footnote{See \func{ReportAttribute} and
		\func{ReportData} in \NumNameRef{sec:SmokeyApi}.} or actions
		are completed.

		\item[NoFile] Disable writing results to file.

	\end{Definition}

	\item[SerialNumberSource] Specify the source of the serial number that
	will be used when reporting test results.  The effects of this property
	are contingent on \prop{ResultsBehavior}.  It is considered a fatal
	error when the specified identifier is undefined and results are to be
	written.

	\begin{Definition}

		\item[SrNm] Use the value of \nvram{SrNm} from syscfg.  This is
		the default when \prop{SerialNumberSource} is not defined.

		\item[MLB\#] Use the value of \nvram{MLB\#} from syscfg.

	\end{Definition}

	\item[LogCollectorControl] Modifies Smokey's interaction with
	LogCollector.  The effects of this property are contingent on
	\prop{ResultsBehavior}.

	\begin{Definition}

		\item[Semaphore] Update
		\filename{.FactoryLogsWaitingToBeCollected} at the time when
		\filename{PDCA.plist} is written.  This is default when
		\prop{LogCollectorControl} is not defined.

		\item[None] Disable modification of
		\filename{.FactoryLogsWaitingToBeCollected}.  This is typically
		the behavior under the purview of Earthbound.

	\end{Definition}

	\item[ControlBitAccess] Modifies Smokey's interaction with the DUT
	control bits area.  Although control bits are a type of result, they
	are independent of \prop{ResultsBehavior}, and controlled exclusively
	by \prop{ControlBitAccess}.

	\begin{Definition}

		\item[Default] Enables control bit writing when appropriate for
		the test sequence.  This is the default when
		\prop{ControlBitAccess} is not defined.

		\item[ReadOnly] Control bits will not be modified.\footnote{For
		retest purposes, Smokey will presently take it one step further
		and disable checks for previous control bit writes.} This is
		typically the behavior under the purview of Earthbound.

	\end{Definition}

\end{Property}

\subsubsection{Test Root Properties}
\label{sec:TestRootProperties}

\begin{PropertyTableContains}
	\prop{FailScript}             & String           & Optional & No  &           \\
	\prop{NumberOfTimesToRun}     & Number           & Required & No  &           \\
	\prop{BehaviorOnFail}         & String           & Required & Yes &           \\
	\prop{Arguments}              & Dict. of Strings & Optional & No  &           \\
	\prop{Tests}                  & Array of Dict.   & Required & No  & Test Item \\
\end{PropertyTableContains}

These properties define the top of the test order and therefore required to be
defined at the root of the plist.  These are a subset of the test item
properties.

\begin{Property}

	\item[FailScript] User-defined Lua function to invoke when a failure is
	detected.

	\item[NumberOfTimesToRun] The \prop{Tests} property will be executed
	this many iterations.

	\item[BehaviorOnFail] Controls how Smokey proceeds after encountering a
	failure.\footnote{See section \NumNameRef{sec:FailureHandling}.}  The
	value at this level defines default the behavior for all tests in the
	sequence.

	\begin{Definition}

		\item[KeepGoing] Continue with the rest of the sequence.

		\item[StopAfterFailedAction] Abort the sequence after an action
		fails.

		\item[StopAfterFailedIteration] Abort after all
		\prop{NumberOfTimesToRun} iterations.

		\item[StopAfterFailedTest] Abort after all child tests are
		complete.

	\end{Definition}

	\item[Arguments] Global arguments for the sequence.\footnote{See
	section \NumNameRef{sec:TestArguments}.\label{fn:GlobalArguments}} This
	is a dictionary of argument names and Lua literals.

	\item[Tests] An ordered array of test items.

\end{Property}

\subsubsection{Test Item Properties}
\label{sec:TestItemProperties}

\begin{PropertyTableContains}
	\prop{TestName}           & String           & Optional (cf. \prop{ActionToExecute})       & No  &           \\
	\prop{FailScript}         & String           & Optional                                    & No  &           \\
	\prop{NumberOfTimesToRun} & Number           & Required                                    & No  &           \\
	\prop{BehaviorOnAction}   & String           & Optional (\propval{None})                   & No  &           \\
	\prop{BehaviorOnFail}     & String           & Optional (cf. parent \prop{BehaviorOnFail}) & Yes &           \\
	\prop{ThisBehaviorOnFail} & String           & Optional (cf. \prop{BehaviorOnFail})        & No  &           \\
	\prop{Arguments}          & Dict. of Strings & Optional                                    & No  &           \\
	\prop{ActionToExecute}    & String           & Required (alt. for \prop{Tests})            & No  &           \\
	\prop{Tests}              & Array of Dict.   & Required (alt. for \prop{ActionToExecute})  & No  & Test Item \\
\end{PropertyTableContains}

The meat of the Smokey schema are the test items.  They are the basic
operating unit of the sequencer.  Test items may be nested within each other.

\begin{Property}

	\item[TestName] Text string naming the test item.  The effective test
	name defaults to the value of \prop{ActionToExecute} if omitted.

	\item[FailScript] User-defined Lua function to invoke when a failure is
	detected.\footnote{See section
	\NumNameRef{sec:SequenceFunctions}.\label{fn:SeqFun}}

	\item[NumberOfTimesToRun] The \prop{Tests} or \prop{ActionToExecute}
	property will be executed this many iterations.

	\item[BehaviorOnAction] Additional steps required before invoking
	\prop{ActionToExecute}.  Requires \prop{ActionToExecute} to be defined.

	\begin{Definition}

		\item[None] Do nothing.  This is the default if
		\prop{BehaviorOnAction} is not specified.

		\item[SaveState] Save the state of the sequence to
		file.\footnote{See section \NumNameRef{sec:FileOutput}.}  If
		the DUT is interrupted due to power loss, reboot, or otherwise,
		the Smokey will automatically continue once the DUT boots up.

	\end{Definition}

	\item[BehaviorOnFail] Override the \prop{BehaviorOnFail} value
	inherited from parent tests.  The value at this level cascades as the
	default value for lower levels.

	\item[ThisBehaviorOnFail] Override the inherited \prop{BehaviorOnFail}
	for the current test only.  The value at this level does not cascade.

	\item[Arguments] Arguments for the associated Lua function, in the same
	syntax as global arguments.\footref{fn:GlobalArguments}  Requires
	\prop{ActionToExecute} to be defined.

	\item[ActionToExecute] User-defined Lua function to
	invoke.\footref{fn:SeqFun}  Precludes \prop{Tests} in the same test
	item.

	\item[Tests] An ordered array of test items.  Precludes
	\prop{ActionToExecute} in the same test item.

\end{Property}

\subsection{Smokey Lua API}
\label{sec:SmokeyApi}

Smokey provides Lua scripting interfaces to interact with the DUT, EFI diags,
and with Smokey itself.  On top of the standard Lua facilities, these will be
the crux of sequence actions.  The following sections will describe the
Smokey API.

Some function arguments will be optional and will be noted with an asterisk.
Following the Lua convention, optional arguments at the end of a function's
argument list may simply be omitted during a call.  Optional arguments in the
middle must be passed as \keyword{nil}.

\subsubsection{Command Execution API}

\paragraph{\func{Shell} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
Shell(~\param{CommandLine}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{CommandLine} & String & Yes  & EFI diags command line \\
\end{ApiTable}
\end{minipage}

Execute the string \param{CommandLine} as if it was typed at the EFI command
shell.  Output is captured into the global table \func{Last}.

\func{Shell} will inspect the command output for failures.  If any are
detected, it will raise an exception with a string describing the first fault
detected.  If the sequence action doesn't catch this exception, Smokey will
catch it by default.

Failures are defined below.

\begin{Descriptive}

	\item[Non-zero Exit Code] The convention for EFI commands is to return
	zero for success.  All other values indicate some kind of failure.

	\item[Error Message Detected]  The text ``ERROR:'' is the label for
	error messages.  If this string is found, the command is considered to
	have failed regardless of exit code.

\end{Descriptive}

\paragraph{\func{Last} Table}

\begin{LuaStruct}
	\func{CommandLine} & String & The string passed into \func{Shell}.                      \\
	\func{ExitCode}    & Number & Command return code. Zero means success.                  \\
	\func{RawOutput}   & String & All console output from the command.                      \\
	\func{Output}      & String & Same as \func{RawOutput}, but stripped of error messages. \\
\end{LuaStruct}

This global table is updated each time \func{Shell} is called.  Scripts can use
this table to inspect the most recent command's result or parse its output.

\subsubsection{PDCA Reporting API}

\paragraph{\func{ReportData} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
~\param{WithinLimits}~ = ReportData(~\param{Name}~, ~\param{Value}~, ~\param{Units*}~, ~\param{LowerLimit*}~, ~\param{UpperLimit*}~,
                   ~\param{PassedOrMessage*}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{Name}            & String  & Yes      & Local identifier for this datum                 \\
	\param{Value}           & Number  & Yes      & Value for this datum                            \\
	\param{Units}           & String  & Optional & Dimension and magnitude (e.g., ``mV'' or ``s'') \\
	\param{LowerLimit}      & Number  & Optional & Must be in the same units as \param{Value}      \\
	\param{UpperLimit}      & Number  & Optional & Must be in the same units as \param{Value}      \\
	\param{PassedOrMessage} & Boolean & Optional & Forces data failure when \keyword{false}        \\
	\param{PassedOrMessage} & String  & Optional & Forces data failure with failure message        \\
\end{ApiTable}
\end{minipage}

Record a named key-value pair for the current iteration of the current test
item.  Smokey will create a unique identifier for the data when generating PDCA
results.

Specifying \param{LowerLimit} or \param{UpperLimit} will cause Smokey to
individually include those limits in the PDCA results.  Defining either limit
will subject \param{Value} to bounds checking, so \param{Name} will be marked
as passed or failed according to the strictest applicable criteria below,
subject to the available limits.  Smokey will automatically generate an
appropriate failure message for PDCA.

\begin{Equations}
\begin{align}
\text{\param{LowerLimit}} \le{} & \text{\param{Value}} \le{} \text{\param{UpperLimit}} \\
                                & \text{\param{Value}} \le{} \text{\param{UpperLimit}} \\
\text{\param{LowerLimit}} \le{} & \text{\param{Value}}
\end{align}
\end{Equations}

Data may be forcibly failed by passing either \keyword{false} or a string for
\param{PassedOrMessage}.  In the former case, Smokey will automatically
generate a failure message for the datum.  In the latter case, the
caller-provided string is used instead.  Both cases take precedence over any
limit checks.  Values \keyword{true} and \keyword{nil} are ignored for
\param{PassedOrMessage}.

In addition to PDCA reporting, failed data will also affect the current test
result.  Refer to section \NumNameRef{sec:DataCascading}.  Exceptions are not
thrown for data failures.

\func{ReportData} will return \keyword{true} or \keyword{false} based on the
limits provided and \param{PassedOrMessage}.  If no limits are provided, the
return value is \keyword{true} by default.

\param{Units} can be specified without defining limits.

\paragraph{\func{ReportAttribute} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
ReportAttribute(~\param{Name}~, ~\param{Value}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{Name}  & String & Yes & Global identifier for this attribute \\
	\param{Value} & String & Yes & Value for this attribute             \\
\end{ApiTable}
\end{minipage}

Record a key-value pair for the DUT.  PDCA treats this data as specific to the
unit rather than specific to any specific factory test.

There is a single namespace for attributes shared across the entire sequence.

\subsubsection{Text Output API}

\paragraph{Text Output Routing}

Smokey offers a suite of functions for generating loggable text.  Each accepts
a routing parameter to specify output destinations, as defined below.

\begin{Definition}

	\item["Full" \textnormal{or} nil] Send output to both console and file.

	\item["ConsoleOnly"] Send output to console only.

	\item["FileOnly"] Send output to file only.

	\item["None"] Ignore output.

\end{Definition}

The user output routing logic is affected by the \prop{LogBehavior} property.
Console output is controlled solely by the routing parameter.  However, file
output is gated if \prop{LogBehavior} is set to \propval{ConsoleOnly} or
\propval{NoLogging}.

\paragraph{\func{WriteString} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
WriteString(~\param{String*}~, ~\param{Routing*}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{String}  & String & Optional & String to print      \\
	\param{Routing} & String & Optional & Desired destinations \\
\end{ApiTable}
\end{minipage}

Output a string with the given routing.  Repeated calls can be used to generate
a line of text from smaller pieces.

When interleaved with Smokey-generated text, a horizontal line of dashes is
automatically emitted in order to delineate user text.

\paragraph{\func{PrintString} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
PrintString(~\param{String*}~, ~\param{Routing*}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{String}  & String & Optional & String to print      \\
	\param{Routing} & String & Optional & Desired destinations \\
\end{ApiTable}
\end{minipage}

This function is largely identical to \func{WriteString}.  However, similar to
the Lua \func{print} function, a newline character is automatically emitted
after \param{String}.

\paragraph{\func{PrintStep} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
PrintStep(~\param{String*}~, ~\param{Routing*}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{String}  & String & Optional & String to print      \\
	\param{Routing} & String & Optional & Desired destinations \\
\end{ApiTable}
\end{minipage}

Output a string to provide a trace of test activity.  Routing logic will be
applied.  As with \func{PrintString}, a newline is automatically emitted after
\param{String}.

When Smokey's sequence trace is active, \param{String} is decorated to match
the Smokey output.  The argument \param{String} is printed in the context of
the current test item: the generated line is preceded by a time stamp and the
current node ID.  \param{String} is indented by the depth of the current node
within the sequence

When the sequence trace is inactive, \param{String} is unadorned.

For the purposes of delineating user- and Smokey-generated text, such as when
interleaving calls to \func{PrintString} and \func{WriteString}, \param{String}
is considered to come from Smokey.  This makes it easier to delineate trace
output from test output.

\subsubsection{File Locator API}
\label{sec:FileLocatorApi}

\paragraph{\func{require} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
require(~\param{modname}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{modname} & String & Yes & Module name or module path \\
\end{ApiTable}
\end{minipage}

The Lua \func{require} function is the standard interface for loading and
executing external code.  The \filename{.lua} extension is implied and must be
omitted from \param{modname}.

Smokey configures the search path such that \param{modname} can be either in a
shared location or specific to the test sequence.  The path precedence is
defined by the templates below, where \param{modname} is substituted for the
``?'' symbol.

\begin{SearchPaths}

	\item[] Platform-specific shared module search paths\footnote{See
	section \NumNameRef{sec:PlatformSpecificModule}.}

	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/Shared/?/Platform/\param{Platform}/init.lua}}
	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/Shared/?/Platform/\param{Platform}.lua}}
	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/Shared/?/\param{Platform}/init.lua}}
	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/Shared/?/\param{Platform}.lua}}

\end{SearchPaths}

\begin{SearchPaths}[resume]

	\item[] Shared module search paths\footnote{See section
	\NumNameRef{sec:ModulesAndSmokey}.}

	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/Shared/?/init.lua}}
	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/Shared/?.lua}}

\end{SearchPaths}

\begin{SearchPaths}[resume]

	\item[] Sequence search paths\footnote{See section
	\NumNameRef{sec:FolderLayout}.}

	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/\param{Sequence}/\param{Platform}/?.lua}}
	\label{itm:RequirePlatformPath}

	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/\param{Sequence}/?.lua}}

\end{SearchPaths}

Search path \WordRef{itm:RequirePlatformPath} is sequence- and
platform-specific, so it is included only when it exists and Smokey uses the
sequence definition files from that directory.

Note that \param{modname} follows Lua convention, so it is possible to have
hierarchies of modules both in the shared directory and local to the sequence
itself.

\paragraph{\func{FindSequenceFile} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
~\param{ResolvedPath}~ = FindSequenceFile(~\param{RelativePath}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{RelativePath} & String & Yes & Path to file \\
\end{ApiTable}
\end{minipage}

Given the file path \param{RelativePath} and the search order below, return a
path to the file appropriate for the DUT.  The returned string can then be used
with functions like \func{io.open}.  If the file is not found, an exception is
thrown.

The search order is similar to the \func{require} search path.

\begin{SearchPaths}
	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/\param{Sequence}/\param{platform}}}
	\item {\LstStyle\FixSlash{nandfs:/AppleInternal/Diags/Logs/Smokey/\param{Sequence}}}
	\item {\LstStyle\param{RelativePath}}
\end{SearchPaths}

The \param{platform} path is included only when it exists and Smokey uses the
sequence definition files from that directory.  As a last resort, Smokey will
try the path \param{RelativePath} as-is if the previous paths do not work.

\subsubsection{System Inspection API}

\paragraph{\func{PlatformInfo} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
~\param{InfoValue}~ = PlatformInfo(~\param{InfoName}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{InfoName} & String & Yes & Platform info selector \\
\end{ApiTable}
\end{minipage}

Programmatically inspect the device under test.  Return platform-specific
information related to the string \param{InfoName}.  The type of
\param{InfoValue} varies according to \param{InfoName}.

The supported values for \param{InfoName} are listed below.  Unsupported values
will cause an exception.

\begin{Definition}

	\item[PlatformName] The name of the general platform as a string.  This
	is the same as the platform name used for loading platform-specific
	test sequences.  This is also the same as the platform name reported by
	the EFI diags \cmdline{version} command.

	\item[ModelName] The name of the particular model within the platform
	as a string.  For example, the model name can be used to differentiate
	variants of a platform that do not have a baseband radio.  Where
	applicable, the model name may also indicate whether the DUT is a DEV
	board.

	\item[BoardId] A read-out of the board ID strapping pins as a number.
	This can be used to numerically qualify the model name, or identify
	whether the DUT is an MLB or DEV board.

	\item[BoardRevision] A read-out of the board revision strapping pins as
	a number.

	\item[Simulation] Returns a boolean indicating whether or not the
	current code is being executed under Smokey Simulator.

\end{Definition}

The \func{PlatformInfo} function is available any time Lua code is running.
However, use at sequence or module load time should be limited to scenarios
where Smokey's automatic platform identification mechanisms\footnote{See
sections \NumNameRef{sec:FolderLayout} and
\NumNameRef{sec:PlatformSpecificModule}.} are insufficient.

\subsubsection{Module Name API}
\label{sec:ModuleNameApi}

\paragraph{Module Context}

Smokey can provide hierarchical information to modules while they are loaded by
\func{require}.  After a module has loaded, these functions are
unsupported.\footnote{See section \NumNameRef{sec:HierarchicalModules}.}

All naming functions return a string suitable for use with \func{require}.

\paragraph{\func{ModuleName} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
~\param{FullName}~ = ModuleName(~\param{Level*}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{Level} & Number & Optional & Hierarchical depth \\
\end{ApiTable}
\end{minipage}

Get the full name of the currently loading module. The optional argument
\param{Level} can be used to retrieve the names of parent modules.

\begin{Definition}

	\item[Omitted] When \param{Level} is omitted, the full name of the
	current module is returned.

	\item[Positive] Values of \param{Level} $> 0$ designate the name of
	the module at the level relative to the top-level module.  When
	\param{Level} is 1, the top-level module name is returned.

	\item[Negative] Values of \param{Level} $< 0$ designate levels relative
	to the current module.  A value of -1 refers to the current module, -2
	refers to the parent module, and so on.

\end{Definition}

\paragraph{\func{SubmoduleName} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
~\param{FullName}~ = SubmoduleName(~\param{SubName}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{SubName} & String & Yes & Relative submodule name \\
\end{ApiTable}
\end{minipage}

Construct a submodule name based on the current top-level module.  The string
returned is a concatenation of the top-level module name and the
\param{SubName} parameter, with a dot between.

\paragraph{\func{ChildModuleName} Function}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
~\param{FullName}~ = ChildModuleName(~\param{ChildName}~)
\end{SmokeyApi}

\begin{ApiTable}
	\param{ChildName} & String & Yes & Child submodule name \\
\end{ApiTable}
\end{minipage}

Construct a submodule name based on the current submodule.  The string returned
is a concatenation of the current module name and the \param{ChildName}
parameter, with a dot between.

The functionality of \func{ChildName} is similar to, but simpler than,
constructing a child module name using the arguments passed to a module by
\func{require}.\footnote{The \keyword{...} (dot-dot-dot) variable holds the
module parameters passed by \func{require}.}

\subsection{Data Submission to PDCA}

Smokey defines \func{ReportData} as the main interface for generating
parametric data for the PDCA system.  Each datum is uniquely identified for
completeness.  See section \NumNameRef{sec:DesignForFactoryUse} for more
details on the exact conversion process.

\subsection{User-Defined Files}

As described section \NumNameRef{sec:FolderLayout}, sequence folders may
contain arbitrary files in addition to those required by Smokey.  Developers
are free to supply ancillary data files, preallocate auxiliary output files, or
split the sequence's Lua code across multiple files.

It is recommended that user files be accessed via \func{require} and
\func{FindSequenceFile} rather than hard-coding any paths.  This makes it much
easier to migrate code from one sequence to another, and to switch environments
between Smokey and Smokey Simulator.  Additionally, any code that needs to be
shared between sequences should be implemented as a shared module.

\subsection{Exception Handling}

As in regular Lua, exceptions in Smokey may be of any data type.\footnote{See
section \NumNameRef{sec:LuaExceptions}.} Smokey takes advantage of this fact to
apply metadata to the error messages that it throws.  Test sequences must be
aware of this behavior and explicitly call \func{tostring} on any exceptions
from Smokey API functions that are to be printed or otherwise manipulated like
strings.  This is good practice even for exceptions not generated by Smokey.

\subsection{Sequence Functions}
\label{sec:SequenceFunctions}

Smokey passes state information to the sequence functions that it calls.  Note
that positional arguments not mentioned here are reserved for future use.

\subsubsection{\prop{ActionToExecute} Prototype}

\begin{minipage}{\linewidth}
\begin{SmokeyApi}
function ~\param{ActionHandler}~ (~\param{ArgTable}~)
\end{SmokeyApi}

\begin{HandlerApiTable}
	\param{ArgTable} & Table & Test item arguments \\
\end{HandlerApiTable}
\end{minipage}

Smokey calls a function with prototype \param{ActionHandler} when it processes
a test item that defines \prop{ActionToExecute}.  Test success is assessed by
the return value of \param{ActionHandler} as well as any run-time
errors.\footnote{See section \NumNameRef{sec:PassFailCriteria}.}

Arguments from the sequence properties and command line are passed in as a
single table.\footnote{See section \NumNameRef{sec:TestItemArguments}.}

\subsubsection{\prop{FailScript} Prototype}

%\begin{minipage}{\linewidth}
\begin{SmokeyApi}
function ~\param{FailureHandler}~ ()
\end{SmokeyApi}
%\end{minipage}

Smokey calls a function with prototype \param{FailureHandler} when a test item
fails.\footnote{See section \NumNameRef{sec:FailureHandling}.}

No arguments are currently defined.

\subsection{Test Arguments}
\label{sec:TestArguments}

Argument passing allows test sequences and individual test items to receive
configuration either by default (via \filename{Main.plist}) or on the fly (via
the command line).  Additionally, arguments allow a single Lua function to be
used multiple times in a sequence with varying behavior.

Arguments are presented to sequences in three ways.  Global arguments, which
are meant to configure the entire sequence, are prepared by Smokey and made
available to the sequence when it is first loaded.  Test arguments, which are
specific to a test item in the sequence, are passed to test actions at run
time.  Both global and test arguments are stored as key-value pairs in an
argument table, so normal Lua semantics can be used to retrieve individual
arguments and handle optional arguments.

The third way of accessing arguments is the global table \func{args} defined by
Lua.  This is the entire command line as provided by the shell.  Smokey stops
processing arguments when it sees a standalone double dash, so any command line
arguments after that are fair game for test sequences.  Note, however, that
this method is the least preferred of the three.

\subsubsection{Argument Syntax and Specification}

Arguments are defined in key-value fashion.  The method for specifying
arguments mimics Lua syntax in order to make it easy to interact with Lua code.

On the command line, keys and values are joined by an equal sign like a Lua
table initialization.\footnote{See section
\NumNameRef{sec:SeqCmdLineArguments}.\label{fn:CmdLineArgs}}  Key names can be
bare if they are purely alphanumeric.  Otherwise, key names must be quoted in
order to facilitate parsing.  Multiple arguments can be specified
simultaneously by separating them with commas.

In a plist file, keys and values are defined in a dictionary of
strings.\footnote{See sections \NumNameRef{sec:TestRootProperties} and
\NumNameRef{sec:TestItemProperties}.}  Key names are used verbatim, so there is
no need to quote special characters.  All plist values must be strings, even if
they are ultimately converted into a different type.

For both command line and plist arguments, the argument values must be in the
form of a Lua literal.  Numbers are to be stored as a sequence of textual
digits, strings are to be quoted, and \keyword{nil} must be bare (no
quotes).\footnote{Currently, tables are not fully supported.}  No special
effort is made to coalesce argument values, so sequences must not assume that
arguments with identical values are guaranteed references to the same
entity.\footnote{See sections \NumNameRef{sec:DynamicBinding} and
\NumNameRef{sec:DataMutation}.}

Figure \ref{fig:ArgumentProperties} shows an abbreviated example of arguments
as properties.

\begin{figure}[h]

	\begin{CenteredPropertyList}{18em}
	\Root{Main.plist}{
		\String{SequenceName}{HelloWorld Example}
		\Number{SchemaFormat}{1}
		\Dictionary{Arguments}{
			\String{Designation}{"World"}
		}
		\Array{Tests}{
			\Dictionary{Item 0}{
				\String{ActionToExecute}{HelloWorld}
				\Dictionary{Arguments}{
					\String{Salutation}{"Hello"}
				}
			}
			\Dictionary{Item 1}{
				\String{ActionToExecute}{GoodbyeWorld}
				\Dictionary{Arguments}{
					\String{Salutation}{"Goodbye"}
					\String{Repetitions}{3}
				}
			}
		}
	}
	\end{CenteredPropertyList}

	\caption{Abbreviated Global and Test Argument Properties Example}
	\label{fig:ArgumentProperties}

\end{figure}

From the command line, the same arguments can be specified as shown below.

\begin{CommandLine}
smokey HelloWorld \
	--args 'Designation="World"' \
	--testargs 'HelloWorld,Saluation="Hello"' \
	--testargs 'GoodbyeWorld,Saluation="Goodbye",Repetitions=3'
\end{CommandLine}

\subsubsection{Argument Override and Overlay}

A differentiating trait of command line-specified arguments is that they can
create, modify, or remove predefined arguments.

Smokey uses the definitions from the sequence plist to create an initial
argument table in Lua.  If no arguments are defined, an empty table is used
instead.  Key-value assignments from the command line are then executed in the
context of the inital table to form the final argument table.  This creates the
following scenarios:

\begin{Descriptive}

	\item[New Argument] An argument name from the command line that does
	not exist in the argument table will create a new argument.  This can
	be used to implement hidden or private arguments.

	\item[Argument Exists, Value is Non-\keyword{nil}] An argument name
	from the command line that exists in the argument table will replace
	the predefined value.

	\item[Argument Exists, Value is \keyword{nil}] Explicitly assigning an
	argument the value \keyword{nil} from the command line will remove the
	argument from the argument table.

\end{Descriptive}

Due to Lua's dynamic typing, the run-time type of an argument value may
ultimately change from the type implied in the sequence plist definition.
Additionally, arguments may appear and disappear.  Sequence scripts must be
tolerant of these situations.

\subsubsection{Global Arguments}

Global arguments defined by the \prop{Arguments} root property or by the
\cmdline{--arg} command line option\footref{fn:CmdLineArgs} are stored in the
\func{GlobalArguments} table, which is a global Lua variable.  The table is
defined before any test code is loaded, so it is available for immediate use by
the sequence.

\func{GlobalArguments} may be empty if no arguments are defined or the default
arguments are deleted via \cmdline{--args}.

\subsubsection{Test Item Arguments}
\label{sec:TestItemArguments}

Like global arguments, test arguments are stored in a Lua table.  Smokey
constructs the argument table from the \prop{Arguments} test item property and
the \cmdline{--testargs} command line option,\footref{fn:CmdLineArgs} then
passes the table to actions as the first function argument.\footnote{See
section \NumNameRef{sec:SequenceFunctions}.}

The test argument table may be empty if no arguments are defined or the default
arguments are deleted via \cmdline{--testargs}.

\subsubsection{Arguments in Use}

The properties in figure \ref{fig:ArgumentProperties} can be combined with the
code below to create an argument-based sequence.

\begin{LuaCode}[linewidth=4.5in]
function HelloWorld (Arguments)
	local Command =
		string.format("echo '%s, %s'; ",
			Arguments.Salutation,
			GlobalArguments.Designation)
	Shell(string.rep(Command, Arguments.Repetitions or 1))
end

function GoodbyeWorld (Arguments)
	local Command =
		string.format("echo '%s, cruel %s'; ",
			Arguments.Salutation,
			GlobalArguments.Designation)
	Shell(string.rep(Command, Arguments.Repetitions or 1))
end
\end{LuaCode}

Ignoring Smokey-generated text (or setting \prop{LogBehavior} to
\propval{NoLogging}) gives the output below with the default arguments.

\begin{TerminalOutput}
Hello, World
Goodbye, cruel World
Goodbye, cruel World
Goodbye, cruel World
\end{TerminalOutput}

Notice that ``Hello'' and ``Goodbye'' come from test arguments, whereas
``World'' is a global argument for use by all tests.  \param{Repetitions} is an
optional argument in the code above that defaults to 1, but is set to 3 in
\func{GoodbyeWorld}.

\subsection{External Code Dependencies}
\label{sec:ExternalCodeDependencies}

Smokey integrates tightly with Lua's \keyword{require} function in order to
provide structured access to external code.  This enables the
\cmdline{--dependencies} command line option to list the modules and source
files used by test sequences.\footnote{See section \NumNameRef{sec:CmdArgs}.}

Dependency information is collected while loading sequence code and displayed
before execution of the test sequence.  Smokey gathers the list from global
code outside of any function definitions.  Files that are manually loaded by
file operations and \func{load}, or loaded at run time from parametric
information, unfortunately, can not be detected by Smokey ahead of time, and
are excluded.

\subsection{Sequence Development Quick Start}

The quickest way to start developing a Smokey sequence is to duplicate an
existing one.  A member of the EFI diags team can provide these files.

However, it's possible to start from scratch by taking note of the file
organization described in section \NumNameRef{sec:Fundamentals}.  For
example, the following commands will create a sequence named
``MySequence'' for the X99 platform.  These commands need to be run at
the command line of a host computer while in the Smokey folder of a
file tree root.

\begin{CommandLine}
mkdir MySequence
touch MySequence/X99.lua
touch MySequence/X99.plist
dd if=/dev/zero of=MySequence/PDCA.plist bs=1m count=1
dd if=/dev/zero of=MySequence/Smokey.log bs=1m count=10
dd if=/dev/zero of=MySequence/Earthbound.sig bs=1k count=1
echo SKIP > MySequence/.FactoryLogsWaitingToBeCollected
dd if=/dev/zero \
	of=MySequence/.FactoryLogsWaitingToBeCollected \
	count=1020 bs=1 seek=4
\end{CommandLine}

The specific selection of output files can vary with due to specific sequence
properties.  Some files can be omitted if Smokey will not be writing to
them.\footnote{See section \NumNameRef{sec:FileOutput}.}

The Lua file will be created, but empty.  A text editor can be used to fill it
with the appropriate content.

The plist file will likewise be empty.  A text editor can also be used to fill
it, but a purpose-built application like Xcode is highly recommended.  At a
minimum, the required properties and one test item must be defined, as shown in
figure \ref{fig:MinimalSeqProps}.

\begin{figure}[h]

	\begin{CenteredPropertyList}{20em}
	\Root{X99.plist}{
		\String{SequenceName}{MySequence}
		\String{SequenceVersion}{20120816}
		\Number{SchemaFormat}{1}
		\String{BrickRequired}{1A}
		\String{BehaviorOnFail}{StopAfterFailedAction}
		\Number{NumberOfTimesToRun}{1}
		\Array{Tests}{
			\Dictionary{Item 0}{
				\String{ActionToExecute}{MyAction}
				\Number{NumberOfTimesToRun}{1}
			}
		}
	}
	\end{CenteredPropertyList}

	\caption{Minimal Sequence Properties}
	\label{fig:MinimalSeqProps}

\end{figure}

Once the files are created, they should be rooted onto the
DUT.\footnote{Consult iOS documentation for details on file roots, how they
work, and how to apply them to a DUT.}

\subsection{Developing Code on DUT}

This feature is not yet available.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Developing Modules}

% \subsection{Summary}
% 
% Smokey now implements support for versioned modules via the new
% \func{ModuleName}, \func{SubmoduleName}, and \func{ChildModuleName} functions.
% The rest of this document will explain how these functions work as well as how
% modules work in the Lua and Smokey environments.

\subsection{Lua Modules and the Smokey Environment}
\label{sec:ModulesAndSmokey}

In Lua nomenclature, a module is external code that a Lua script can load into
the interpreter's virtual machine.  The terms ``module'' and ``library'' are
almost interchangeable.  Pedantically speaking, however, ``module'' is the
proper name and is the one used in this document.

Lua modules can take the form of Lua source files, Lua bytecode, or C
libraries.  Within the EFI diags environment, C libraries are difficult to
support in the general case, as is Lua bytecode, so modules in the Smokey
environment will typically be Lua source code.

The mechanism for loading modules is Lua's built-in \keyword{require} function,
which takes a module name as a parameter.  The name can be in dotted notation,
with a dot or period character delineating the levels of the module hierarchy;
Lua uses the dots to navigate through modules the same way that it navigates a
directory tree.  Two generic examples of \keyword{require} syntax are shown
below.

\begin{LuaCode}[linewidth=4.5in]
require "Statistics"
\end{LuaCode}

\begin{LuaCode}[linewidth=4.5in]
local Stats = require "Statistics"
\end{LuaCode}

Smokey configures \keyword{require} to use a common location for modules shared
between test sequences.\footnote{See section \NumNameRef{sec:FileLocatorApi}.}
This allows complex modules to be stored in an eponymous directory and loaded
by instructing Smokey to execute the module's \filename{init.lua} file.  Once
invoked, the entry point for complex modules may call \keyword{require} on any
number of submodules within its hierarchy.  Simple modules can be defined in a
single eponymous Lua source file.

More details about standard Lua modules and a general background of how the
language and interpreter support them can be found in the official
``Programming in Lua'' books.  Pay special attention to the documentation for
the Lua version used by Smokey,\footnote{Smokey is currently based on Lua 5.2.}
as a lot of information floating around references features that are deprecated
in later Lua versions.

The \keyword{require} function is also a general way to locate and load
external code.  In Smokey, it is configured to allow test sequences to spread
their code over several files.  The mechanism for doing so is largely the same
as for modules, but will not be discussed here.

\subsection{Module Convention and Terminology}

Lua does not define nor enforce any policy on how modules are to be implemented
or used.  Consequently, modules are metaphorically unbridged islands within an
archipelago and users are allowed to freely access any modules at any time.  It
is therefore up to convention to establish structure, so we define the
following terminology:

\begin{Definition}

	\item[Module] External code that can be loaded by Lua.

	\item[Module name] The name, including all dots, as specified when
	loading the module.  This is the same as the argument to
	\keyword{require}.  Module names are a way to relay the organization
	and purpose of external code.

	\item[Module path] Collection of names that represents a path from one
	point in a module hierarchy to another.  Concatenating the names, with
	a dot between names, produces a module name.  For example:
	\filename{A}, \filename{B}, and \filename{C} can form a module path and
	have the name \filename{A.B.C}.

	\item[Top-level module] A module that serves as the entry point for a
	collection of related code.  Its name typically does not have dots
	except in the case of versioned modules.  A top-level module is not
	considered a submodule nor a child module.

	\item[Submodule] A module that is underneath a top-level module.  Its
	name has at least one dot.  Related submodules are under the same
	top-level module.  Submodules may be above or under other submodules
	within the same hierarchy.

	\item[Child module] A module that is directly underneath another
	module.  There is exactly one step in the module path from the parent
	module to the child module.  In the example of \filename{A.B.C},
	\filename{A.B} is the parent module and \filename{A.B.C} is the child
	module.

\end{Definition}

Nomenclature can vary according to context.  Some developers refer to single
modules as libraries or groups of modules as packages.  For the sake of this
documentation, we will simply call them modules, with the qualifiers defined
above.

\subsection{Hierarchical Modules}
\label{sec:HierarchicalModules}

\subsubsection{Locating Hierarchical Modules}

It is usually straightforward to identify the location of a module file on the
filesystem.  However, directories with no immediate files can pose a challenge
and there are two interesting scenarios.

In the first scenario, a module name in the middle of a module path is an empty
directory.  Assume that the module names \filename{A}, \filename{A.B.C}, and
\filename{A.B.D} can be used with \keyword{require} successfully.  The name
\filename{A.B} might be an empty directory and therefore not valid for
\keyword{require}.  This can be confusing to module users who expect that any
given module name will automatically load all submodules beneath it.  So, while
this scenario is legal, it is not encouraged.

In the second scenario, the root of a module name is an empty directory.
Assume that \filename{A.B} is a valid module, but \filename{A} represents an
empty directory.  Like the previous scenario, it is legal.  However, this
design is rather inefficient for users and is discouraged except in the cases
of versioned modules.

\subsubsection{Hiearchical Module Access}

Regarding module usage, Smokey expects that test sequences will reference
shared modules by their top-level module name only.  Module developers may be
tempted to allow users direct access to submodules, but this is highly
discouraged in the Smokey environment.  Such functionality should be refactored
into a separate top-level module instead.  Figure \ref{fig:SharedModuleLayout}
illustrates the two approaches.

\begin{lrbox}{\LeftBoxA}
\begin{NestedLuaCode}
require "FFT.Support.FastTrig"
require "FFT.Support.SimpleVector"
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\RightBoxA}
\begin{NestedLuaCode}[linewidth=1.5in]
require "FastTrig"
require "SimpleVector"
\end{NestedLuaCode}
\end{lrbox}

\begin{figure}[h]

	\begin{SideBySideGrid}

		\HeadingRow{Discouraged layout}{Encouraged layout}

	\NextRow

		% Discouraged layout
		\begin{NestedDirectoryTree}
		\Root{Shared}{
			\Directory{FFT}{
				\Directory{Support}{
					\Directory{FastTrig}{
						\File{init.lua}
					}
					\Directory{SimpleVector}{
						\File{init.lua}
					}
				}
				\File{init.lua}
			}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		% Encouraged layout
		\begin{NestedDirectoryTree}
		\Root{Shared}{
			\Directory{FFT}{
				\File{init.lua}
			}
			\Directory{FastTrig}{
				\File{init.lua}
			}
			\Directory{SimpleVector}{
				\File{init.lua}
			}
		}
		\end{NestedDirectoryTree}

	\NextRow

		% Discouraged layout
		\UseLuaCodeBox{\LeftBoxA}

	\NextColumn

		% Encouraged layout
		\UseLuaCodeBox{\RightBoxA}

	\LastRow
	\end{SideBySideGrid}

	\caption{Shared Module Layout}
	\label{fig:SharedModuleLayout}

\end{figure}

\subsubsection{Referring to Related Modules}

Submodules of a top-level module may want to reference children modules or even
other submodules within the same hierarchy.  The stock Lua approach
necessitates that the full name of the desired module be known, so a submodule
will often need to know both its own name and also the name of of the top-level
module. Smokey provides several functions for composing module names that makes
it easier to use \keyword{require} without hard-coding too much
knowledge.\footnote{See section \NumNameRef{sec:ModuleNameApi}.}  At the time
of module loading, these functions provide a way to load other modules or
record information for later use.

\begin{Definition}

	\item[ModuleName] Retrieve the current module name.

	\item[SubmoduleName] Generate a module name under the same top-level
	module.

	\item[ChildModuleName] Generate a module name below the current module.

\end{Definition}

This allows the Lua code in figure \ref{fig:SubmoduleNameExample} to be
rewritten for Smokey.

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\A\init.lua
\begin{lrbox}{\LeftBoxA}
\begin{NestedLuaCode}[linewidth=1in]
require "A.B"
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\A\B\init.lua
\begin{lrbox}{\LeftBoxB}
\begin{NestedLuaCode}[linewidth=1in]
require "A.B.C"
require "A.D.E"
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\A\init.lua
\begin{lrbox}{\RightBoxA}
\begin{NestedLuaCode}[linewidth=2in]
require(ChildModuleName "B")
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\A\B\init.lua
\begin{lrbox}{\RightBoxB}
\begin{NestedLuaCode}[linewidth=2in]
require(ChildModuleName "C")
require(SubmoduleName "D.E")
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\BoxA}
{\LstSize\FixSlash{Shared/A/init.lua}}
\end{lrbox}

\begin{lrbox}{\BoxB}
{\LstSize\FixSlash{Shared/A/B/init.lua}}
\end{lrbox}

\begin{figure}[h]

	\begin{LuaPorting}
		\usebox{\BoxA} & \UseLuaCodeBox{\LeftBoxA} & \UseLuaCodeBox{\RightBoxA} \\
		\usebox{\BoxB} & \UseLuaCodeBox{\LeftBoxB} & \UseLuaCodeBox{\RightBoxB} \\
	\end{LuaPorting}

	\caption{Submodule Name API in Use}
	\label{fig:SubmoduleNameExample}

\end{figure}

The \func{ModuleName}, \func{SubmoduleName}, and \func{ChildModuleName}
functions must be used within the context of a \keyword{require} call.  In
other words, they can not be used at run time, when tests call into a module.

Although it is possible to deduce some of the requested information statically,
contextual information (like original file locations) is lost shortly after a
module is loaded into the Lua virtual machine.  This means that, within a
module file, calls to these functions must be made outside of any function
definitions, which allows Lua to execute code as it parses source.  This also
means that such modules must be invoked with \keyword{require} rather than
Lua's \keyword{load} or \keyword{loadfile} functions.  Such an arrangement
allows Smokey to build context identifying the parts of the module hierarchy.

\subsection{Module Versions}

Smokey's module versioning is a way to enable future module development while
simultaneously shielding existing users from divergent changes and allowing
bleeding edge users to automatically pick up the latest code.  Like standard
Lua modules, versioned modules rely on convention, but they also make use of
unique Smokey features.

\subsubsection{Loading Versioned Modules}

The mechanism for loading module versions remains the same \keyword{require}
function as before.  Smokey extends the \keyword{require} behavior such that a
specific module version can be chosen by using the version number as the
submodule name.  For example: To select version \filename{11A} of top-level
module \filename{A}, pass to \keyword{require} the concatenation of the
unversioned module name, a single dot, and the version number.  Note that this
form of module name is the only kind of top-level module name that should
include a dot.

There is a special \filename{Latest} version number that is reserved for the
most recent copy of the module code.  Smokey can automatically alias an
unversioned module name to the \filename{Latest} version as a convenience to
users.  Unversioned modules will continue to work as they did before,
regardless of these features.

Smokey amends the behavior of \keyword{require} so that users do not need to be
aware of the \filename{Latest} alias.  This means, for example, that the return
value and side effects of \keyword{require} are the same whether the name
\filename{A} or \filename{A.Latest} are used.  Code bases that mix the two
styles of names should work seamlessly.

\subsubsection{Versioned Module Folder Layout}

As the version naming scheme alludes to, module versions are created by putting
the module's files in a subdirectory of the module's main directory. Additional
versions can be created by putting code into other subdirectories of the main
directory.  The \filename{Latest} version is created simply by using a
subdirectory name of \filename{Latest}.  This organization will help clearly
delineate module code from versioning artifacts.

The names of module versions are free-form within the limits of standard Lua
module names.  However, it is encouraged to name them after iOS build train
numbers since the development of Smokey test sequences is primarily
synchronized with iOS releases, which is, in turn, synchronized to hardware
product schedules.

\begin{lrbox}{\LeftBoxA}
\begin{NestedLuaCode}[linewidth=3in]
require "A"        -- Not a versioned module
require "B"        -- Resolves to "B.Latest"
require "B.Latest" -- Bleeding edge
require "B.10B"    -- Brighton version
require "B.11A"    -- Innsbruck version
\end{NestedLuaCode}
\end{lrbox}

\begin{figure}[h]

	\begin{SideBySideGrid}

		\begin{NestedDirectoryTree}
		\Root{Shared}{
			\Directory{A}{
				\File{init.lua}
			}
			\Directory{B}{
				\Directory{10B}{
					\File{init.lua}
				}
				\Directory{11A}{
					\File{init.lua}
				}
				\Directory{Latest}{
					\File{init.lua}
				}
			}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		\UseLuaCodeBox{\LeftBoxA}

	\LastRow
	\end{SideBySideGrid}

	\caption{Invoking Versioned and Unversioned Modules}
	\label{fig:InvokingVersionedModules}

\end{figure}

As an example of how module versions are implemented and used, consider figure
\ref{fig:InvokingVersionedModules}, which illustrates a shared module directory
structure and the corresponding Lua code to load them.  There are several
points to notice with this hierarchical approach.

\begin{Descriptive}

	\item[Unversioned Modules] Module \filename{A} is not versioned, so the
	normal \keyword{require} behavior will successfully find
	\filename{A\textbackslash{}init.lua}.

	\item[Versioned Modules] Module \filename{B} has three versions, one of
	which is the bleeding edge.  Passing the module name \filename{B} to
	\keyword{require} causes Smokey to automatically load
	\filename{B.Latest} once it fails to find
	\filename{B\textbackslash{}init.lua}.  Directly specifying the version
	nets the expected results because they can be found via the
	\keyword{require} search paths.

\end{Descriptive}

An important detail here is that a module should not be set up for both
versioned and unversioned behavior.  For example, in the module \filename{B}
above, there is no guarantee of behavior if
\filename{B\textbackslash{}init.lua} exists.  Users of module \filename{B} must
either load a specific version directly, or rely on Smokey to effect the alias
from \filename{B} to \filename{B.Latest}.  Module developers should not attempt
to implement their own aliasing schemes.

\subsection{Versioned Module Life Cycle}

\subsubsection{Branching and Submission Considerations}

Shared modules in the Smokey environment will need to follow the life cycle of
factory software and comply with restore bundle mastering.  This means that
module development needs to consider the effects of branches, separate code
submissions, and how files are populated on a device under test.

Branches allow software to be stabilized while development continues on the
trunk of the software tree.  Modules and module versions can be branched, and
changes on those branches are eligible for merging, just like any other
software, so they will fit normal development processes.  Unlike branches,
versions have a distinction in that they can coexist multiply and
contemporaneously on a DUT.  This is advantageous if changes on several
different branches need to be combined into a single branch (or even trunk) and
minimal code merges are desired: the active code on each branch can be made
into different versions, which would allow all of the branched code to live
alongside each other.  Of course, this source code multiplication has practical
implications, so it must be weighted against the advantages of outright
merging.

Because versioned modules will be shared between products, submissions to build
trains must be made from a common B\&I project and registered to the appropriate
targets.  This will ensure that the same files are used across all devices and
that there is no overlapping of roots.  It is highly encouraged that all shared
modules, and all common Smokey files for that matter, be submitted as one
repository.

\subsubsection{Choosing a Module Version}

Versioned modules must take into consideration the appropriate times during
product development for users to reference an established version number and
when the \filename{Latest} version should be used instead.  It is generally
accepted that completed products should use the version number established for
the applicable build train, but there are two approaches to making the journey
from the start of an engineering cycle and the final code lockdown.

One choice is to do module development on \filename{Latest} and have users
either reference \filename{Latest} directly or rely on the alias.  For example,
either \filename{A} or \filename{A.Latest} could be passed to
\keyword{require}.  At the end of the cycle, a unique version number would be
created and all module users would be migrated to the newly established
version.  This approach has the advantage of ensuring the use of the latest
code, but has the disadvantage of coordinated churn for both module user and
module developer at the end.

The other choice is to put bleeding edge code in \filename{Latest} and
periodically sync \filename{Latest} to a version established for the product
cycle.  Users would always reference the specific version being developed, so
this approach has the advantage of having code point to the correct version
from the beginning.  Another advantage is that experimental code can be
submitted to \filename{Latest} without immediately disturbing a product build.
The disadvantage is that the synchronization must be done manually.

Regardless of which approach is taken, module developers and users should agree
to a convention up front and synchronize whenever versions need to change.
Remember to keep in mind that notifications must be made not only to the
immediate Smokey sequences using the versioned module, but also any modules
that rely on the versioned code and any sequences that rely on those modules.

\subsection{Transitioning to Versioned Modules}

Changing an unversioned module to be versioned is straightforward.   The
process basically boils down to moving files into subdirectories and editing
\keyword{require} calls.

A module that is a bare Lua source file would be renamed to \filename{init.lua}
and moved into a subdirectory. For example, to make \filename{11A} and
\filename{Latest} versions of \filename{SimpleModule}, the original
\filename{SimpleModule.lua} file would be moved and copied as shown in figure
\ref{fig:SimpleModuleVersioning}.

\begin{figure}[h]

	\begin{SideBySideGrid}

		\HeadingRow{Simple Unversioned}{Simple Versioned}

	\NextRow

		% Before
		\begin{NestedDirectoryTree}
		\Root{Shared}{
			\File{SimpleModule.lua}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		% After
		\begin{NestedDirectoryTree}
		\Root{Shared}{
			\Directory{SimpleModule}{
				\Directory{11A}{
					\File{init.lua}
				}
				\Directory{Latest}{
					\File{init.lua}
				}
			}
		}
		\end{NestedDirectoryTree}

	\LastRow
	\end{SideBySideGrid}

	\caption{Simple Module Versioning}
	\label{fig:SimpleModuleVersioning}

\end{figure}

Modules that are in their own directory, modules that are spread across several
files, and those that contain submodules are all handled similarly.  Module
files must be moved into a subdirectory of the main module directory.  Next,
all uses of \keyword{require} to load submodules must be changed to use the
\func{SubmoduleName} or \func{ChildModuleName} functions to compose module
names.  The example in figure \ref{fig:ComplexModuleVersioning} shows how files
move when \filename{11A} and \filename{Latest} versions of
\filename{ComplexModule} are created.

\begin{figure}[h]

	\begin{SideBySideGrid}

		\HeadingRow{Complex Unversioned}{Complex Versioned}

	\NextRow

		% Before
		\begin{NestedDirectoryTree}
		\Root{Shared}{
			\Directory{ComplexModule}{
				\Directory{Submodule}{
					\File{init.lua}
				}
				\File{Support.lua}
				\File{init.lua}
			}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		% After
		\begin{NestedDirectoryTree}
		\Root{Shared}{
			\Directory{ComplexModule}{
				\Directory{11A}{
					\Directory{Submodule}{
						\File{init.lua}
					}
					\File{Support.lua}
					\File{init.lua}
				}
				\Directory{Latest}{
					\Directory{Submodule}{
						\File{init.lua}
					}
					\File{Support.lua}
					\File{init.lua}
				}
			}
		}
		\end{NestedDirectoryTree}

	\LastRow
	\end{SideBySideGrid}

	\caption{Complex Module Versioning}
	\label{fig:ComplexModuleVersioning}

\end{figure}

For the aforementioned examples, it is assumed that \filename{11A} was the most
recent milestone and development will continue with the \filename{Latest}
version.  When the transition occurs, Smokey test sequences that rely on old
behavior must be updated to reference the \filename{11A} version.  Others can
remain as-is.

\subsection{Developing Versioned Modules}

For the most part, versioned modules are developed just like unversioned
modules.  However, special care must be taken to ensure that references to
files and variables resolve correctly.

\subsubsection{Submodule Name Resolution}

Direct references to submodules should be avoided.  When the \filename{Latest}
code is branched off to various version directories, direct use of submodule
names can cause \keyword{require} to load code from the wrong directory if the
new versions are not immediately patched.  This can be avoided by using
\func{SubmoduleName} and \func{ChildModuleName} to generate module names.  Both
functions use Smokey to identify the top-level module name and version, which
allows the correct module names to be generated on the fly.  The end result is
that identical \keyword{require} calls will work correctly regardless of the
module version.

\subsubsection{Module Member Scoping}

Global variables and functions should be used carefully.  This guideline
originates from standard Lua modules and has important ramifications in Smokey.
With versioned modules, the situation might arise that a test sequence uses
distinct modules \filename{A} and \filename{B}, and both need to use different
versions of module \filename{C}.  If module \filename{C} exports functions or
variables to the global namespace, the two versions can overwrite each other's
globals.  Because of Lua's type system, this trampling is both legal and
silent, potentially causing unintended behavior that can only be detected at
runtime.  

The way to avoid conflicts in the global namespace is to take advantage of
scoping rules and localize both the contents and use of each module.  The Lua
\keyword{local} keyword helps achieve this.  Additionally, this paradigm is
supported by the ability to pass values back to the user through the
\keyword{require} function.  The two can be used together with the following
guidelines:

\begin{Descriptive}

	\item[Localize] Most, if not all, variables should be declared
	\keyword{local}.

	\item[Encapsulate] A table should be created to store the environment
	of the module.

	\item[Contain] Module state and cached information should be stored in
	either the module table or its metatable.

	\item[Expose Selectively] Public functions and variables should be put
	into the module table.

	\item[Coalesce] The module table should be passed back to the user.
	Module users should store the return value of \keyword{require} in a
	local variable.

	\item[Support] Optionally, create a global copy of the module table for
	compatibility.

\end{Descriptive}

A key aspect of the solution is the creation and use of a module table. This
puts the module interface in a scope that won't be trampled by other versions
of the same module.  Another important aspect is that the semantics of
\keyword{require} grant all submodules access to the same module table rather
than distinct copies of the table.

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\Latest\Package.lua
\begin{lrbox}{\RightBoxA}
\begin{NestedLuaCode}[linewidth=3.25in]
return {}
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\Latest\A.lua
\begin{lrbox}{\RightBoxB}
\begin{NestedLuaCode}[linewidth=3.25in]
local Package = require(SubmoduleName "Package")
Package.A = { FooText = "LatestFoo" }
function Package.A:Foo ()
	return self.FooText
end
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\Latest\B.lua
\begin{lrbox}{\RightBoxC}
\begin{NestedLuaCode}[linewidth=3.25in]
local Package = require(SubmoduleName "Package")
Package.B = { BarText = "LatestBar" }
function Package.B:Bar ()
	return self.BarText
end
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\Latest\init.lua
\begin{lrbox}{\RightBoxD}
\begin{NestedLuaCode}[linewidth=3.25in]
require(ChildModuleName "A")
require(ChildModuleName "B")
MyModule = require(SubmoduleName "Package")
return MyModule
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\BoxA}
{\LstSize\FixSlash{MyModule/Latest/Package.lua}}
\end{lrbox}

\begin{lrbox}{\BoxB}
{\LstSize\FixSlash{MyModule/Latest/A.lua}}
\end{lrbox}

\begin{lrbox}{\BoxC}
{\LstSize\FixSlash{MyModule/Latest/B.lua}}
\end{lrbox}

\begin{lrbox}{\BoxD}
{\LstSize\FixSlash{MyModule/Latest/init.lua}}
\end{lrbox}

\begin{figure}[h]

	\begin{CodeFilesListing}
		\usebox{\BoxA} & \UseLuaCodeBox{\RightBoxA} \\
		\usebox{\BoxB} & \UseLuaCodeBox{\RightBoxB} \\
		\usebox{\BoxC} & \UseLuaCodeBox{\RightBoxC} \\
		\usebox{\BoxD} & \UseLuaCodeBox{\RightBoxD} \\
	\end{CodeFilesListing}

	\caption{Encapsulation of Multiple Submodules in a Single Table}
	\label{fig:SubmoduleEncapsulation}

\end{figure}

Figure \ref{fig:SubmoduleEncapsulation} shows an example of the above
guidelines.  It also demonstrates how code can be split across several files
while bounding the module's public interface within a single table.  The code
implements an module table and returns it to the user that called
\keyword{require}.  It also creates a global variable that refers to the same
module table.  (Note that the global instance replaces any existing variable of
the same name.)  Within the module table, there are submodules \filename{A} and
\filename{B} that implement their own functionality.  Both submodules take
advantage of \keyword{require} semantics to install their interfaces to the
same module table.  The top-level module does likewise to return the populated
table.

\subsection{Platform-Specific Modules}
\label{sec:PlatformSpecificModule}

\subsubsection{Platform-Specialization for Modules}

Under certain circumstances, modules may want to tailor their configuration or
overload their API to suit the platform of the device under test.  Smokey
directly supports these goals in two ways.  The first way is the
\func{PlatformInfo} function for inspecting platform details.\footnote{See
section \NumNameRef{sec:SmokeyApi}.}  The second way is to automatically pick a
platform-specific entry point when loading a module.

Modules are canonically loaded by passing their top-level name to the
\keyword{require} function.  Smokey extends the normal \keyword{require}
behavior by adding platform-specific paths to the module search
path.\footnote{See section \NumNameRef{sec:FileLocatorApi}.}  This enables
developers to completely replace the default entry point, with little overhead,
in order to tailor their module's behavior to the device under test.

When a user calls \keyword{require}, the platform-specific paths are queried
first.  If the appropriate files are found, the search stops and the platform
code is loaded.  If a module does not define platform-specific entry points, or
no defined platforms match the DUT, the default module entry point is used.

Note that the platform-specific paths are in effect for any \keyword{require}
call, not just those for top-level modules.  This can have implications when
loading submodules, so the module package layout must keep this in mind.  On
the other hand, this also means that submodules can be made platform-specific
should the need arise.

\subsubsection{Platform-Specific Module Entry Point}

Module developers have a couple of options for taking advantage of
platform-specific entry points.  These are illustrated in figure
\ref{fig:PlatformModuleLayouts}, with one example given per platform search
path.  Developers are free to choose the one that fits the complexity and
organization of their code.

\begin{figure}[p]

	\begin{SideBySideGrid}

		\HeadingRow{Platform File}{Platform Directory}

	\NextRow

		% Platform entry point is in a file:
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\File{init.lua}
			\File{N78.lua}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		% Platform entry point is in a directory:
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\File{init.lua}
			\Directory{N78}{
				\File{init.lua}
			}
		}
		\end{NestedDirectoryTree}

	\NextRow

		% One blank row for spacing

	\NextRow

		\HeadingRow{Nested Platform File}{Nested Platform Directory}

	\NextRow

		% Platform entry point is in a file under the \filename{Platform} directory:
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\File{init.lua}
			\Directory{Platform}{
				\File{N78.lua}
			}
		}
		\end{NestedDirectoryTree}

	\NextColumn

		% Platform entry point is in a directory under the \filename{Platform} directory:
		\begin{NestedDirectoryTree}
		\Root{MyModule}{
			\File{init.lua}
			\Directory{Platform}{
				\Directory{N78}{
					\File{init.lua}
				}
			}
		}
		\end{NestedDirectoryTree}

	\LastRow
	\end{SideBySideGrid}

	\caption{Platform-Specific Module Layouts}
	\label{fig:PlatformModuleLayouts}

\end{figure}

\subsubsection{Complex Platform-Specific Modules}

As implied by the preceding description, the platform-specific entry point
replaces the normal entry point.  Each entry point must, therefore, make the
effort to configure and load the entirety of the module package.  Larger, or
more complex, modules can ease this burden by placing all of the common
initialization in a single submodule that each of the entry points can
reference.

A simple illustration of this is shown in figure
\ref{fig:PlatformSubmoduleEncapsulation}.  The example code can be extended to
support model variations within a platform by combining control logic with the
\func{PlatformInfo} function.

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\Package.lua
\begin{lrbox}{\RightBoxA}
\begin{NestedLuaCode}[linewidth=3.25in]
return {}
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\Common.lua
\begin{lrbox}{\RightBoxB}
\begin{NestedLuaCode}[linewidth=3.25in]
local Package = require(SubmoduleName "Package")
Package.Common = "Common"
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\Default.lua
\begin{lrbox}{\RightBoxC}
\begin{NestedLuaCode}[linewidth=3.25in]
local Package = require(SubmoduleName "Package")
Package.Feature = "Default"
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\PlatformSpecific.lua
\begin{lrbox}{\RightBoxD}
\begin{NestedLuaCode}[linewidth=3.25in]
local Package = require(SubmoduleName "Package")
Package.Feature = "PlatformSpecific"
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\init.lua
\begin{lrbox}{\RightBoxE}
\begin{NestedLuaCode}[linewidth=3.25in]
require(SubmoduleName "Common")
require(SubmoduleName "Default")
return require(SubmoduleName "Package")
\end{NestedLuaCode}
\end{lrbox}

% nandfs:\AppleInternal\Diags\Logs\Smokey\Shared\MyModule\N78.lua
\begin{lrbox}{\RightBoxF}
\begin{NestedLuaCode}[linewidth=3.25in]
require(SubmoduleName "Common")
require(SubmoduleName "PlatformSpecific")
return require(SubmoduleName "Package")
\end{NestedLuaCode}
\end{lrbox}

\begin{lrbox}{\BoxA}
{\LstSize\FixSlash{MyModule/Package.lua}}
\end{lrbox}

\begin{lrbox}{\BoxB}
{\LstSize\FixSlash{MyModule/Common.lua}}
\end{lrbox}

\begin{lrbox}{\BoxC}
{\LstSize\FixSlash{MyModule/Default.lua}}
\end{lrbox}

\begin{lrbox}{\BoxD}
{\LstSize\FixSlash{MyModule/PlatformSpecific.lua}}
\end{lrbox}

\begin{lrbox}{\BoxE}
{\LstSize\FixSlash{MyModule/init.lua}}
\end{lrbox}

\begin{lrbox}{\BoxF}
{\LstSize\FixSlash{MyModule/N78.lua}}
\end{lrbox}

\begin{figure}[p]

	\begin{CodeFilesListing}
		\usebox{\BoxA} & \UseLuaCodeBox{\RightBoxA} \\
		\usebox{\BoxB} & \UseLuaCodeBox{\RightBoxB} \\
		\usebox{\BoxC} & \UseLuaCodeBox{\RightBoxC} \\
		\usebox{\BoxD} & \UseLuaCodeBox{\RightBoxD} \\
		\usebox{\BoxE} & \UseLuaCodeBox{\RightBoxE} \\
		\usebox{\BoxF} & \UseLuaCodeBox{\RightBoxF} \\
	\end{CodeFilesListing}

	\caption{Encapsulation of Multiple Submodules in a Platform-Specific Module}
	\label{fig:PlatformSubmoduleEncapsulation}

\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Using Smokey Shell}

Certain features of Smokey are available as an interactive shell running on the
DUT.  This means that it is possible to test code snippets and EFI commands
without loading files onto the DUT.

Currently, this feature is limited to engineering hardware only.  Also, it must
be enabled in the particular build of EFI diags.

\subsection{Smokey Shell Command Line Arguments}

\subsubsection{Start Interactive Interpreter}

\begin{CommandLine}
smokeyshell
\end{CommandLine}

\begin{CommandLine}
smokeyshell ... --interactive
\end{CommandLine}

\begin{CommandLine}
smokeyshell ... -i
\end{CommandLine}

The > (greater-than) prompt will be shown once the shell is running and ready
to accept input.  At this point, it will be possible to type or paste code into
the terminal window.

\subsubsection{Expression Evaluation}

\begin{CommandLine}
smokeyshell ... --execute ~\param{Expression}~
\end{CommandLine}

\begin{CommandLine}
smokeyshell ... -e ~\param{Expression}~
\end{CommandLine}

Execute \param{Expression} as if it had been typed into the interactive
interpreter, then return to the EFI diags shell.  When used multiple times in
one command line, each \cmdline{--execute} is evaluated in order, from left to
right.

When used with \cmdline{--interactive}, all instances of \cmdline{--execute}
are evaluated before bringing up the interactive interpreter.

\subsubsection{Enable Persistence}

\begin{CommandLine}
smokeyshell ... --persist
\end{CommandLine}

\begin{CommandLine}
smokeyshell ... -p
\end{CommandLine}

Retain the state of the Lua virtual machine when returning to the EFI diags
shell.  Subsequent invocations of \cmdline{smokeyshell} will use and update the
persistent VM state.

When persistence is not enabled, a single-use VM is created for each invocation
of \cmdline{smokeyshell}.

\subsubsection{Clear Persistence}

\begin{CommandLine}
smokeyshell ... --reset
\end{CommandLine}

\begin{CommandLine}
smokeyshell ... -r
\end{CommandLine}

Delete the Lua virtual machine left behind by \cmdline{--persist}.

When used with \cmdline{--execute}, \cmdline{--interactive}, or
\cmdline{--persist}, a new VM is created after the old one is deleted.

\subsection{Executing Commands}

The shell supports all of the standard Lua functions and libraries, as well as
the standard interactive Lua shell conventions.  Additionally, the following
Smokey API functions may be used:

\begin{Descriptive}

	\item[Shell] Behaves the same as in Smokey.

	\item[ReportAttribute] Silently ignored.

	\item[ReportData] Silently ignored.

\end{Descriptive}

\subsection{Exiting the Shell}

Pressing \KeyCapsCtrlD{} will end input and quit Smokey Shell.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Smokey Internals}

\subsection{Software Architecture}

Smokey's architecture and its interaction with EFI diags are shown in figure
\ref{fig:SystemArchitecture}.  Software that interfaces directly with the Lua
VM are delineated.  Also shown are the components that are loaded from the
filesystem, as are those provided by the firmware image.

\begin{figure}[p]
\begin{FullWidth}

	\CenteredImage{SmokeySystemDiagram2-Portrait.pdf}

	\caption{Smokey and EFI System Architecture}
	\label{fig:SystemArchitecture}

\end{FullWidth}
\end{figure}

\subsection{Control Files}

Documentation not yet available.

\subsection{Saving State}

Documentation not yet available.

\subsection{Schema Grammar}

Documentation not yet available.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{References}

\subsection{Useful Apple Links}
\label{sec:AppleLinks}

\subsubsection{Smokey Announcements Mailing List}

smokey-announce@group.apple.com\footnote{Restricted access\label{fn:Restricted}}

\subsubsection{Smokey Wiki}

\url{https://ipodwiki.apple.com/wiki/Smokey}\footref{fn:Restricted}

\subsection{Useful Lua Links}
\label{sec:LuaLinks}

\subsubsection{Official Lua Home Page}

\url{http://www.lua.org/home.html}

\subsubsection{Lua Executable Binaries}

\url{http://luabinaries.sourceforge.net/download.html}

\subsubsection{Official Lua 5.2 Reference Manual}

\url{http://www.lua.org/manual/5.2/}

\subsubsection{Lua Programmer's Guide}

\url{http://www.lua.org/pil/}

\subsubsection{Lua Pitfalls and Gotchas}

\url{http://www.luafaq.org/gotchas.html}

\subsubsection{Lua Community Wiki}

\url{http://lua-users.org/wiki/}

\subsubsection{Tutorials and Learning Guides}

\url{http://stackoverflow.com/a/8097810}\footnote{Refers to older Lua language
version}

\subsubsection{Modules}

\url{http://lua-users.org/wiki/ModuleVersioning}

\url{http://lua-users.org/wiki/ModulesTutorial}

\LongUrl{http://stackoverflow.com/questions/14942472/create-suite-of-interdependent-lua-files-without-affecting-the-global-namespace}

