Topic List:
	RPJ: mega-merge walk-through (PW + Gilg)
	Shane: quick way for a code review via branch (since forking)
	Jack: tricky merges (history changing merge and a better way to do)
	Raman: check in, check out, basics
	Alhad: gitâ€™ing started walkthrough
	Bridget: same, merging
	Rashmi: Sharing code between people (pushing branches)
	Tran: Submodules, tagging, gitx/gitk usage
	Joon-sup: Specific steps or cherry picking
	Mike: PR-branch, merging back into some other branch, then merging back to ToT (or vice versa)
	
Starting with the easy topics first:

	git basics:
		
		The most basic thing you need to know with git, is how to checkout a repository, make changes, and 
		push those changes back to the main repo. One thing to keep in mind,
		is that git is entirely distributed: it has no concept of the
		'central' or 'main' repository.  This can frustrate some new people to
		git.  It can definitely make pushing a bit more sketchy, since someone
		can 'sneak in' prior to your checkin, and create merge conflicts for
		you.  Fear not, recovery is generally "not too bad".

		- Checkout a repo

		In 'git' speak, this is known as cloning.  This is aptly named because
		a clone is a fully functional repository.  If you clone the 'main'
		repo, and the server on which that repo lives dies a firey death,
		congratulations, your copy is now the 'main' repo.  This is what git
		was meant to accomplish.  Every clone of the repo is the full history,
		fully featured, and can become the future 'main' repo at any time.

		On with the show:

		git clone <git-URL> [folder name]

		Similar to SVN, you can checkout a repo to a named folder.  The
		folder name is entirely optional, if you're good with the last path
		component of the git URL (minus the .git extension).
		Here's an example:

		$ git clone git@gitlab.sd.apple.com:blackops/shasta.git
		Cloning into 'shasta'...
		remote: Counting objects: 210594, done.
		remote: Compressing objects: 100% (46889/46889), done.
		remote: Total 210594 (delta 147646), reused 208760 (delta 146295)
		Receiving objects: 100% (210594/210594), 431.29 MiB | 10.72 MiB/s, done.
		Resolving deltas: 100% (147646/147646), done.
		Checking connectivity... done
		Checking out files: 100% (16274/16274), done.
		$

		What happened? First, git has the remote end of the network connection
		package itself up (counting, compressing, listing totals).  Secondly,
		it receives the packed up bits (receiving). Finally, it essentially
		replays all the changes that were ever checked into the repo locally 
		(resolving deltas, checking connectivity, checking out).

		Internally, git stores *everything* beyond the first initial checkin
		as a patch file (a diff).  This makes it easy to switch branches: git
		simply reverse patches back to the common ancestor, then patches the
		new diffs from the branch point back to the tip of the new branch.
		Nifty eh?

		Next, we make a change...

		- Staging changes

		Git does not require you to checkin everything that has been changed
		at once.  This is good - doing so would be cumbersome for most
		developers. How it accomplishes this is slightly different than SVN
		(making you spell out each individual file you want to checkin at
		commit time), and perforce (creating individual change lists, allowing
		you to have any number in flight at once).  Git uses a cache (formerly
		called the 'index') of files to checkin. Remember, since git treates
		everything as a patch, it's really staging patch files, not whole
		source files. This shows its power later on (I'll give you an example
		in just a moment - after the more vanilla example).

		So, you made a change to TODO.txt, and you want to check that change
		in.  Here's how it looks:

		$ vim TODO.txt # make some changes here
		$ git status
		# On branch build-fix
		# Changes not staged for commit:
		#   (use "git add <file>..." to update what will be committed)
		#   (use "git checkout -- <file>..." to discard changes in working directory)
		#
		#	modified:   TODO.txt
		#
		no changes added to commit (use "git add" and/or "git commit -a")

		This output here is telling us that nothing is currently staged.  If
		we did 'git commit' right now, it'd yell at us (you have to stage
		first).

		Here's how to stage something:

		$ git add TODO.txt

		It's called 'add' because you're adding the current difference between
		HEAD and your working copy of this file to the cache (remember, as a
		patch).  I keep harping on the patch thing, and here's why: once
		you've staged a file, its state at the time it was staged is captured
		in the cache.  Further changes you make after staging *would not be
		committed* should you commit without another add.  This is actually a
		smart feature (IMHO).  If you did this on accident, here's how it
		would look in 'git status':

		$ git status
		# On branch build-fix
		# Changes to be committed:
		#   (use "git reset HEAD <file>..." to unstage)
		#
		#	modified:   TODO.txt
		#
		# Changes not staged for commit:
		#   (use "git add <file>..." to update what will be committed)
		#   (use "git checkout -- <file>..." to discard changes in working directory)
		#
		#	modified:   TODO.txt
		#
		$

		This is telling you that there are both staged, and unstaged changes
		to TODO.txt.  'git diff --cached' shows you what patch is in the
		cache, and 'git diff' shows you what has changed *relative to the
		cache*.  This is an interesting feature for this reason (if not
		others): let's say you're working on something and get to a point
		where it's good enough to commit, but you still want to try one other
		thing before pulling the trigger.  Simply stage your work, and hammer
		on.  If your experiment pays off, all you have to do is 'git add'
		again, and the sum of the changes will now be staged.  If your
		experiment flops, here's how to revert *only* the unstaged changes:

		$ git checkout -- TODO.txt

		Remember, as far as git is concerned, the previous changes you staged
		are no longer "working directory" changes.  They are pre-commit,
		staged changes.  You have to work harder to unstage them.  Here's how,
		incase you need to know:

		$ git reset HEAD TODO.txt

		Only do this if you want to completely discard your work since HEAD.

		Okay, back to the task at hand, let's check this change in.

		Simple, once you have all changes staged that you want to check in,
		just 'git commit'. Git will ask for a commit message (as normal), and
		will create a new commit object.  Output generally looks like this:

		$ git commit -m "Already fixed the Makefile, removing TODO.txt item"
		[build-fix 57ca58c] Already fixed the Makefile, removing TODO.txt item
		 1 file changed, 5 deletions(-)

		This tells us a number of things:

		[branch hash] commit-msg
		 commit-stats

		In this case, build-fix is our branch, 57ca58c is the short form of
		the SHA-1 hash of this commit object, and we changed 1 file (5 lines
		deleted).

		Nifty.

		Remember what I said before about 'no central server'.  No one else
		currently knows anything about this change.  If you messed something
		up, broke something, or otherwise want to go back (command-Z), DO NOT
		PUSH. I repeat: DO NOT PUSH unless you are okay with someone else
		basing their work on this commit.

		We'll cover "undo" later on.

		For now, assume you're good with this commit, and want to make it
		available to all.  What you need to do now, is 'push' this change to
		the upstream repository.

		$ git push
		Counting objects: 5, done.
		Delta compression using up to 4 threads.
		Compressing objects: 100% (3/3), done.
		Writing objects: 100% (3/3), 315 bytes | 0 bytes/s, done.
		Total 3 (delta 2), reused 0 (delta 0)
		To git@gitlab.sd.apple.com:blackops/shasta.git
		   de4a6e5..57ca58c  build-fix -> build-fix

		The last line tells us that this push brought the tip of the upstream
		'build-fix' branch from its old commit (de4a6e5) to this new one 
		(57ca58c).  commits are like revision numbers with one major
		difference: they capture the entire path from the beginning of time to
		this state by way of hashing all their parents. It's kind of like a
		linked list.  This is another powerful feature of git (that most
		people hate when they are new to git). More on that later...

		That's the most basic workflow. 

		Here's a couple pro tips:
			- Always pull before you push.
				This will update your local branch and merge any upstream
				changes in.  You're less likely to get a rejected push if you
				pull first.  Workorder should be this: 
					git pull,
					make changes,
					git commit, 
					git pull, 
						(fix any merge problems), 
					git push

		- Putting the pieces together: PR-branch workflow
		
		Here at Apple, there is a concept of a PR-branch (PR meaning Per
		Radar).  PR-branches is the same thing as a bug-fix branch (See
		git-branch-strategy.txt for bug-fix branch explanation). Here's how it
		works in practice.  Let's say there is a bug assigned to you, based on
		broken behavior in the top-of-tree branch (in git, that's generally
		'master').  What you would do is this:
			1. Update 'master' to latest and greatest
			2. Reproduce the bug (if it doesn't repro, send the radar back
			asking them to double-check with latest ToT code).
			3. Assuming the bug repros, you would create a new PR-branch.
			4. Work on your PR-branch, making whatever changes you need.
			5. Conduct code-review on this branch (I'll show you a couple of
			ways to do this in a moment).
			6. Merge your changes back into whatever your source branch was
			(in our case here, we're assuming 'master').

			1. Update 'master' to latest and greatest

			$ git checkout master
			Switched to branch 'master'
			Your branch is behind 'origin/master' by 7 commits, and can be
			fast-forwarded.
			  (use "git pull" to update your local branch)

			Here, git is telling us that we're behind. So we do this to get up
			to date:

			$ git pull
			Updating 3d2881f..08e7784
			Fast-forward
			<trimmed output>
		     18 files changed, 237 insertions(+), 96 deletions(-)

			At this point, assuming no issues have popped up, we're at the latest
			state of the 'master' branch.  Now we can create our PR-branch.
			Let's assume our radar number is 143535644, here's what we do:

			$ git checkout -b PR-143535644
			Switched to a new branch 'PR-143535644'

			Now we can make changes on this branch in isolation, without
			effecting the 'master' branch or the upstream server *at all*.
			When working on PR-branches, please, feel free to commit code,
			even if it's only partially functional, gross, hacky, whatever.
			In git, commit early and commit often.  It's easy to go back to
			previous state, but nearly impossible to recover code you never
			committed.

			Commit early, commit often.

			When you're ready to conduct code review, there's 2 main ways to
			do this:
				1. push your branch, and have someone else pull it down and
				review.
				2. Generate patches, and email them.
			
			Let's go through option 1: pushing your PR-branch, reviewing,
			merging, then removing your PR-branch from the upstream once done.

			Pushing your branch:

			What you need to do is tell git which upstream server to push your
			branch to (you can push to any remote repository, it doesn't have
			to be the central repo).  Generally, for us, we'll be using a
			remote named 'origin'.  You need to specify the remote upstream,
			and the branch name to push.

			$ git push -u origin PR-143535644
			Total 0 (delta 0), reused 0 (delta 0)
			To git@gitlab.sd.apple.com:blackops/shasta.git
			 * [new branch]      PR-143535644 -> PR-143535644
			 Branch PR-143535644 set up to track remote branch PR-143535644 from origin.  

			At this point, someone else can pull this branch down and review
			it. Here's how they would do it.

			$ git fetch
			From gitlab.sd.apple.com:blackops/shasta
			 * [new branch]      PR-143535644 -> origin/PR-143535644

			This shows us that git has now pulled down the reference (pointer)
			to PR-143535644 from the upstream repo named 'origin'.

			$ git checkout PR-143535644
			Branch PR-143535644 set up to track remote branch PR-143535644
			from origin.
			Switched to a new branch 'PR-143535644'

			This shows us that our local repo now has a new branch, with the
			same name as the upstream branch, which is setup to track the
			upstream branch (makes pushing and pulling work).

			Now, to see an overall picture of the tip of this branch versus
			whats in 'master' (this would be the subject of the pre-merge code
			review), you would do this:

			$ git diff PR-143535644 master
			diff --git a/sync.sh b/sync.sh
			index f2a93a7..e8f3347 100755
			--- a/sync.sh
			+++ b/sync.sh
			@@ -1,2 +1,2 @@
			 #!/bin/sh
			 -git merge perforce poop
			 +git merge perforce
			 \ No newline at end of file

			This is the only demo change I made for this purpose.  Now, if I
			wanted to merge this back to master, here's what I would do:
				1. go back to the master branch
				2. merge the PR-143535644 into master
				3. push the changes..

			$ git checkout master
			Switched to branch 'master'
			
			($ git pull !!!)
			
			$ git merge PR-143535644 [-m msg]
			Updating 08e7784..94f8933
			Fast-forward
			 sync.sh | 2 +-
			 1 file changed, 1 insertion(+), 1 deletion(-)
			
			At this point, the PR-branch has been merged back to master.  We
			can now push (though I'm not going to). Finally, we want to tidy
			up the remote server by telling it this PR-branch is no longer
			needed.  We do this with a special push that tells the remote git
			to stop tracking PR-143535644

			$ git push origin :PR-143535644
			To git@gitlab.sd.apple.com:blackops/shasta.git
			 - [deleted]         PR-143535644

			This special syntax (the colon) means this:
			git push (to) origin (local-ref/branch name):(remote-ref/branch name)

			By leaving the local branch name empty, we're telling the remote
			side to stop tracking that branch (effectively deleting it).  Now,
			nothing is lost, if you know the commit hash of the tip of that
			branch, you can always regenerate it.

			That's workflow #1: the push, pull review (followed by deleting
			the branch).

			Generating Patches:

			This is fairly simple.  To generate a complete patch of the change
			between the tip of a new branch and master, use 'git diff' and
			redirect the output to a patch file.

			$ git diff master PR-143535644 > changes.patch

			Another option is to take all the commits on your branch, squash
			them into one commit, and use git format-patch to create a single
			patchfile.  The advantage here is that the remote person who's
			doing the reviewing can go ahead and check the changes in, if she
			thinks they're good-to-go.  All they have to do is apply the patch
			with git.

			Here's how it works:
				1. Once done with work on your branch, you'll want to make
				sure whichever branch you branched from is up to date.
				2. Now you interactively rebase all your commits.  Every
				commit except the earliest in the list should be set to 'squash'.
				3. You can now 'git commit --amend' to re-word your commit
				message in your checkin.
				3. Finally, git format-patch HEAD^ (generate a patch for the
				most recent commit).

			WARNING: DO NOT SQUASH YOUR COMMIT IF YOU HAVE ALREADY PUSHED.
			That's bad form..

	
	
	Fancy stuff (get to this later):
		- Crypto Signed tags:
			$ git tag -a -s -u 'Ryan Du Bois (Apple Work Laptop Key) <rdub@apple.com>' Shasta-checkpoint-1 ca269dad9e7c76fc8a1cbb88c8acbcc4553b412d

			You need a passphrase to unlock the secret key for
			user: "Ryan Du Bois (Apple Work Laptop Key) <rdub@apple.com>"
			2048-bit RSA key, ID 93098241, created 2013-11-06
			
			Verify:
				$ git tag -v Shasta-checkpoint-1
				object ca269dad9e7c76fc8a1cbb88c8acbcc4553b412d
				type commit
				tag Shasta-checkpoint-1
				tagger Ryan Du Bois <rdub@apple.com> 1384904337 -0800

				Shasta builds a bootable diags image as of this commit
				gpg: Signature made Tue Nov 19 15:39:09 2013 PST using RSA key ID 93098241
				gpg: Good signature from "Ryan Du Bois (Apple Work Laptop Key) <rdub@apple.com>"
			
